// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `agent.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct CreateContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub string_user: ::protobuf::SingularPtrField<StringUser>,
    pub devices: ::protobuf::RepeatedField<Device>,
    pub storages: ::protobuf::RepeatedField<Storage>,
    pub OCI: ::protobuf::SingularPtrField<super::oci::Spec>,
    pub sandbox_pidns: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContainerRequest {
    fn default() -> &'a CreateContainerRequest {
        <CreateContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateContainerRequest {
    pub fn new() -> CreateContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // .grpc.StringUser string_user = 3;


    pub fn get_string_user(&self) -> &StringUser {
        self.string_user.as_ref().unwrap_or_else(|| StringUser::default_instance())
    }
    pub fn clear_string_user(&mut self) {
        self.string_user.clear();
    }

    pub fn has_string_user(&self) -> bool {
        self.string_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_user(&mut self, v: StringUser) {
        self.string_user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_user(&mut self) -> &mut StringUser {
        if self.string_user.is_none() {
            self.string_user.set_default();
        }
        self.string_user.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_user(&mut self) -> StringUser {
        self.string_user.take().unwrap_or_else(|| StringUser::new())
    }

    // repeated .grpc.Device devices = 4;


    pub fn get_devices(&self) -> &[Device] {
        &self.devices
    }
    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::protobuf::RepeatedField<Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::protobuf::RepeatedField<Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::protobuf::RepeatedField<Device> {
        ::std::mem::replace(&mut self.devices, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.Storage storages = 5;


    pub fn get_storages(&self) -> &[Storage] {
        &self.storages
    }
    pub fn clear_storages(&mut self) {
        self.storages.clear();
    }

    // Param is passed by value, moved
    pub fn set_storages(&mut self, v: ::protobuf::RepeatedField<Storage>) {
        self.storages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storages(&mut self) -> &mut ::protobuf::RepeatedField<Storage> {
        &mut self.storages
    }

    // Take field
    pub fn take_storages(&mut self) -> ::protobuf::RepeatedField<Storage> {
        ::std::mem::replace(&mut self.storages, ::protobuf::RepeatedField::new())
    }

    // .grpc.Spec OCI = 6;


    pub fn get_OCI(&self) -> &super::oci::Spec {
        self.OCI.as_ref().unwrap_or_else(|| super::oci::Spec::default_instance())
    }
    pub fn clear_OCI(&mut self) {
        self.OCI.clear();
    }

    pub fn has_OCI(&self) -> bool {
        self.OCI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OCI(&mut self, v: super::oci::Spec) {
        self.OCI = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_OCI(&mut self) -> &mut super::oci::Spec {
        if self.OCI.is_none() {
            self.OCI.set_default();
        }
        self.OCI.as_mut().unwrap()
    }

    // Take field
    pub fn take_OCI(&mut self) -> super::oci::Spec {
        self.OCI.take().unwrap_or_else(|| super::oci::Spec::new())
    }

    // bool sandbox_pidns = 7;


    pub fn get_sandbox_pidns(&self) -> bool {
        self.sandbox_pidns
    }
    pub fn clear_sandbox_pidns(&mut self) {
        self.sandbox_pidns = false;
    }

    // Param is passed by value, moved
    pub fn set_sandbox_pidns(&mut self, v: bool) {
        self.sandbox_pidns = v;
    }
}

impl ::protobuf::Message for CreateContainerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.string_user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.devices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.OCI {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.string_user)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.devices)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storages)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.OCI)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sandbox_pidns = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if let Some(ref v) = self.string_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.storages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.OCI.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.sandbox_pidns != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if let Some(ref v) = self.string_user.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.devices {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.storages {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.OCI.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.sandbox_pidns != false {
            os.write_bool(7, self.sandbox_pidns)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContainerRequest {
        CreateContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &CreateContainerRequest| { &m.container_id },
                    |m: &mut CreateContainerRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &CreateContainerRequest| { &m.exec_id },
                    |m: &mut CreateContainerRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringUser>>(
                    "string_user",
                    |m: &CreateContainerRequest| { &m.string_user },
                    |m: &mut CreateContainerRequest| { &mut m.string_user },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                    "devices",
                    |m: &CreateContainerRequest| { &m.devices },
                    |m: &mut CreateContainerRequest| { &mut m.devices },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Storage>>(
                    "storages",
                    |m: &CreateContainerRequest| { &m.storages },
                    |m: &mut CreateContainerRequest| { &mut m.storages },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oci::Spec>>(
                    "OCI",
                    |m: &CreateContainerRequest| { &m.OCI },
                    |m: &mut CreateContainerRequest| { &mut m.OCI },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sandbox_pidns",
                    |m: &CreateContainerRequest| { &m.sandbox_pidns },
                    |m: &mut CreateContainerRequest| { &mut m.sandbox_pidns },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateContainerRequest>(
                    "CreateContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateContainerRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.string_user.clear();
        self.devices.clear();
        self.storages.clear();
        self.OCI.clear();
        self.sandbox_pidns = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartContainerRequest {
    fn default() -> &'a StartContainerRequest {
        <StartContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartContainerRequest {
    pub fn new() -> StartContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StartContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartContainerRequest {
        StartContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &StartContainerRequest| { &m.container_id },
                    |m: &mut StartContainerRequest| { &mut m.container_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartContainerRequest>(
                    "StartContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartContainerRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StartContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub timeout: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveContainerRequest {
    fn default() -> &'a RemoveContainerRequest {
        <RemoveContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveContainerRequest {
    pub fn new() -> RemoveContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // uint32 timeout = 2;


    pub fn get_timeout(&self) -> u32 {
        self.timeout
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = v;
    }
}

impl ::protobuf::Message for RemoveContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if self.timeout != 0 {
            os.write_uint32(2, self.timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveContainerRequest {
        RemoveContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &RemoveContainerRequest| { &m.container_id },
                    |m: &mut RemoveContainerRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timeout",
                    |m: &RemoveContainerRequest| { &m.timeout },
                    |m: &mut RemoveContainerRequest| { &mut m.timeout },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveContainerRequest>(
                    "RemoveContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveContainerRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecProcessRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub string_user: ::protobuf::SingularPtrField<StringUser>,
    pub process: ::protobuf::SingularPtrField<super::oci::Process>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecProcessRequest {
    fn default() -> &'a ExecProcessRequest {
        <ExecProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecProcessRequest {
    pub fn new() -> ExecProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // .grpc.StringUser string_user = 3;


    pub fn get_string_user(&self) -> &StringUser {
        self.string_user.as_ref().unwrap_or_else(|| StringUser::default_instance())
    }
    pub fn clear_string_user(&mut self) {
        self.string_user.clear();
    }

    pub fn has_string_user(&self) -> bool {
        self.string_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_user(&mut self, v: StringUser) {
        self.string_user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_user(&mut self) -> &mut StringUser {
        if self.string_user.is_none() {
            self.string_user.set_default();
        }
        self.string_user.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_user(&mut self) -> StringUser {
        self.string_user.take().unwrap_or_else(|| StringUser::new())
    }

    // .grpc.Process process = 4;


    pub fn get_process(&self) -> &super::oci::Process {
        self.process.as_ref().unwrap_or_else(|| super::oci::Process::default_instance())
    }
    pub fn clear_process(&mut self) {
        self.process.clear();
    }

    pub fn has_process(&self) -> bool {
        self.process.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process(&mut self, v: super::oci::Process) {
        self.process = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process(&mut self) -> &mut super::oci::Process {
        if self.process.is_none() {
            self.process.set_default();
        }
        self.process.as_mut().unwrap()
    }

    // Take field
    pub fn take_process(&mut self) -> super::oci::Process {
        self.process.take().unwrap_or_else(|| super::oci::Process::new())
    }
}

impl ::protobuf::Message for ExecProcessRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.string_user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.process {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.string_user)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.process)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if let Some(ref v) = self.string_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.process.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if let Some(ref v) = self.string_user.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.process.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecProcessRequest {
        ExecProcessRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ExecProcessRequest| { &m.container_id },
                    |m: &mut ExecProcessRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &ExecProcessRequest| { &m.exec_id },
                    |m: &mut ExecProcessRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringUser>>(
                    "string_user",
                    |m: &ExecProcessRequest| { &m.string_user },
                    |m: &mut ExecProcessRequest| { &mut m.string_user },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oci::Process>>(
                    "process",
                    |m: &ExecProcessRequest| { &m.process },
                    |m: &mut ExecProcessRequest| { &mut m.process },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecProcessRequest>(
                    "ExecProcessRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecProcessRequest {
        static mut instance: ::protobuf::lazy::Lazy<ExecProcessRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecProcessRequest::new)
        }
    }
}

impl ::protobuf::Clear for ExecProcessRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.string_user.clear();
        self.process.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecProcessRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignalProcessRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub signal: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignalProcessRequest {
    fn default() -> &'a SignalProcessRequest {
        <SignalProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignalProcessRequest {
    pub fn new() -> SignalProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 signal = 3;


    pub fn get_signal(&self) -> u32 {
        self.signal
    }
    pub fn clear_signal(&mut self) {
        self.signal = 0;
    }

    // Param is passed by value, moved
    pub fn set_signal(&mut self, v: u32) {
        self.signal = v;
    }
}

impl ::protobuf::Message for SignalProcessRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.signal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.signal != 0 {
            my_size += ::protobuf::rt::value_size(3, self.signal, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.signal != 0 {
            os.write_uint32(3, self.signal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignalProcessRequest {
        SignalProcessRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &SignalProcessRequest| { &m.container_id },
                    |m: &mut SignalProcessRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &SignalProcessRequest| { &m.exec_id },
                    |m: &mut SignalProcessRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "signal",
                    |m: &SignalProcessRequest| { &m.signal },
                    |m: &mut SignalProcessRequest| { &mut m.signal },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignalProcessRequest>(
                    "SignalProcessRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignalProcessRequest {
        static mut instance: ::protobuf::lazy::Lazy<SignalProcessRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SignalProcessRequest::new)
        }
    }
}

impl ::protobuf::Clear for SignalProcessRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.signal = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignalProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignalProcessRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitProcessRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitProcessRequest {
    fn default() -> &'a WaitProcessRequest {
        <WaitProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitProcessRequest {
    pub fn new() -> WaitProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WaitProcessRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitProcessRequest {
        WaitProcessRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &WaitProcessRequest| { &m.container_id },
                    |m: &mut WaitProcessRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &WaitProcessRequest| { &m.exec_id },
                    |m: &mut WaitProcessRequest| { &mut m.exec_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitProcessRequest>(
                    "WaitProcessRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WaitProcessRequest {
        static mut instance: ::protobuf::lazy::Lazy<WaitProcessRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WaitProcessRequest::new)
        }
    }
}

impl ::protobuf::Clear for WaitProcessRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitProcessRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitProcessResponse {
    // message fields
    pub status: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitProcessResponse {
    fn default() -> &'a WaitProcessResponse {
        <WaitProcessResponse as ::protobuf::Message>::default_instance()
    }
}

impl WaitProcessResponse {
    pub fn new() -> WaitProcessResponse {
        ::std::default::Default::default()
    }

    // int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }
}

impl ::protobuf::Message for WaitProcessResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_int32(1, self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitProcessResponse {
        WaitProcessResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "status",
                    |m: &WaitProcessResponse| { &m.status },
                    |m: &mut WaitProcessResponse| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitProcessResponse>(
                    "WaitProcessResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WaitProcessResponse {
        static mut instance: ::protobuf::lazy::Lazy<WaitProcessResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WaitProcessResponse::new)
        }
    }
}

impl ::protobuf::Clear for WaitProcessResponse {
    fn clear(&mut self) {
        self.status = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitProcessResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitProcessResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProcessesRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub format: ::std::string::String,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProcessesRequest {
    fn default() -> &'a ListProcessesRequest {
        <ListProcessesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListProcessesRequest {
    pub fn new() -> ListProcessesRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string format = 2;


    pub fn get_format(&self) -> &str {
        &self.format
    }
    pub fn clear_format(&mut self) {
        self.format.clear();
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        &mut self.format
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.format, ::std::string::String::new())
    }

    // repeated string args = 3;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListProcessesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.format)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.format.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.format);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.format.is_empty() {
            os.write_string(2, &self.format)?;
        }
        for v in &self.args {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProcessesRequest {
        ListProcessesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ListProcessesRequest| { &m.container_id },
                    |m: &mut ListProcessesRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "format",
                    |m: &ListProcessesRequest| { &m.format },
                    |m: &mut ListProcessesRequest| { &mut m.format },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "args",
                    |m: &ListProcessesRequest| { &m.args },
                    |m: &mut ListProcessesRequest| { &mut m.args },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListProcessesRequest>(
                    "ListProcessesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListProcessesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListProcessesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListProcessesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListProcessesRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.format.clear();
        self.args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProcessesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProcessesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProcessesResponse {
    // message fields
    pub process_list: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProcessesResponse {
    fn default() -> &'a ListProcessesResponse {
        <ListProcessesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListProcessesResponse {
    pub fn new() -> ListProcessesResponse {
        ::std::default::Default::default()
    }

    // bytes process_list = 1;


    pub fn get_process_list(&self) -> &[u8] {
        &self.process_list
    }
    pub fn clear_process_list(&mut self) {
        self.process_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_process_list(&mut self, v: ::std::vec::Vec<u8>) {
        self.process_list = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process_list(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.process_list
    }

    // Take field
    pub fn take_process_list(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.process_list, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ListProcessesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.process_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.process_list.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.process_list);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.process_list.is_empty() {
            os.write_bytes(1, &self.process_list)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProcessesResponse {
        ListProcessesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "process_list",
                    |m: &ListProcessesResponse| { &m.process_list },
                    |m: &mut ListProcessesResponse| { &mut m.process_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListProcessesResponse>(
                    "ListProcessesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListProcessesResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListProcessesResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListProcessesResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListProcessesResponse {
    fn clear(&mut self) {
        self.process_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProcessesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProcessesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub resources: ::protobuf::SingularPtrField<super::oci::LinuxResources>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateContainerRequest {
    fn default() -> &'a UpdateContainerRequest {
        <UpdateContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateContainerRequest {
    pub fn new() -> UpdateContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // .grpc.LinuxResources resources = 2;


    pub fn get_resources(&self) -> &super::oci::LinuxResources {
        self.resources.as_ref().unwrap_or_else(|| super::oci::LinuxResources::default_instance())
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: super::oci::LinuxResources) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut super::oci::LinuxResources {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> super::oci::LinuxResources {
        self.resources.take().unwrap_or_else(|| super::oci::LinuxResources::new())
    }
}

impl ::protobuf::Message for UpdateContainerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateContainerRequest {
        UpdateContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &UpdateContainerRequest| { &m.container_id },
                    |m: &mut UpdateContainerRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oci::LinuxResources>>(
                    "resources",
                    |m: &UpdateContainerRequest| { &m.resources },
                    |m: &mut UpdateContainerRequest| { &mut m.resources },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateContainerRequest>(
                    "UpdateContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateContainerRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.resources.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatsContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatsContainerRequest {
    fn default() -> &'a StatsContainerRequest {
        <StatsContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatsContainerRequest {
    pub fn new() -> StatsContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StatsContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatsContainerRequest {
        StatsContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &StatsContainerRequest| { &m.container_id },
                    |m: &mut StatsContainerRequest| { &mut m.container_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatsContainerRequest>(
                    "StatsContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatsContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatsContainerRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StatsContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for StatsContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatsContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PauseContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PauseContainerRequest {
    fn default() -> &'a PauseContainerRequest {
        <PauseContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl PauseContainerRequest {
    pub fn new() -> PauseContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PauseContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PauseContainerRequest {
        PauseContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &PauseContainerRequest| { &m.container_id },
                    |m: &mut PauseContainerRequest| { &mut m.container_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PauseContainerRequest>(
                    "PauseContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PauseContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<PauseContainerRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PauseContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for PauseContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PauseContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PauseContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResumeContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResumeContainerRequest {
    fn default() -> &'a ResumeContainerRequest {
        <ResumeContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResumeContainerRequest {
    pub fn new() -> ResumeContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResumeContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResumeContainerRequest {
        ResumeContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ResumeContainerRequest| { &m.container_id },
                    |m: &mut ResumeContainerRequest| { &mut m.container_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResumeContainerRequest>(
                    "ResumeContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResumeContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ResumeContainerRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ResumeContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ResumeContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResumeContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResumeContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CpuUsage {
    // message fields
    pub total_usage: u64,
    pub percpu_usage: ::std::vec::Vec<u64>,
    pub usage_in_kernelmode: u64,
    pub usage_in_usermode: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CpuUsage {
    fn default() -> &'a CpuUsage {
        <CpuUsage as ::protobuf::Message>::default_instance()
    }
}

impl CpuUsage {
    pub fn new() -> CpuUsage {
        ::std::default::Default::default()
    }

    // uint64 total_usage = 1;


    pub fn get_total_usage(&self) -> u64 {
        self.total_usage
    }
    pub fn clear_total_usage(&mut self) {
        self.total_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_usage(&mut self, v: u64) {
        self.total_usage = v;
    }

    // repeated uint64 percpu_usage = 2;


    pub fn get_percpu_usage(&self) -> &[u64] {
        &self.percpu_usage
    }
    pub fn clear_percpu_usage(&mut self) {
        self.percpu_usage.clear();
    }

    // Param is passed by value, moved
    pub fn set_percpu_usage(&mut self, v: ::std::vec::Vec<u64>) {
        self.percpu_usage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_percpu_usage(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.percpu_usage
    }

    // Take field
    pub fn take_percpu_usage(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.percpu_usage, ::std::vec::Vec::new())
    }

    // uint64 usage_in_kernelmode = 3;


    pub fn get_usage_in_kernelmode(&self) -> u64 {
        self.usage_in_kernelmode
    }
    pub fn clear_usage_in_kernelmode(&mut self) {
        self.usage_in_kernelmode = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage_in_kernelmode(&mut self, v: u64) {
        self.usage_in_kernelmode = v;
    }

    // uint64 usage_in_usermode = 4;


    pub fn get_usage_in_usermode(&self) -> u64 {
        self.usage_in_usermode
    }
    pub fn clear_usage_in_usermode(&mut self) {
        self.usage_in_usermode = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage_in_usermode(&mut self, v: u64) {
        self.usage_in_usermode = v;
    }
}

impl ::protobuf::Message for CpuUsage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_usage = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.percpu_usage)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage_in_kernelmode = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage_in_usermode = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.percpu_usage {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.usage_in_kernelmode != 0 {
            my_size += ::protobuf::rt::value_size(3, self.usage_in_kernelmode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.usage_in_usermode != 0 {
            my_size += ::protobuf::rt::value_size(4, self.usage_in_usermode, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_usage != 0 {
            os.write_uint64(1, self.total_usage)?;
        }
        for v in &self.percpu_usage {
            os.write_uint64(2, *v)?;
        };
        if self.usage_in_kernelmode != 0 {
            os.write_uint64(3, self.usage_in_kernelmode)?;
        }
        if self.usage_in_usermode != 0 {
            os.write_uint64(4, self.usage_in_usermode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CpuUsage {
        CpuUsage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "total_usage",
                    |m: &CpuUsage| { &m.total_usage },
                    |m: &mut CpuUsage| { &mut m.total_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "percpu_usage",
                    |m: &CpuUsage| { &m.percpu_usage },
                    |m: &mut CpuUsage| { &mut m.percpu_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "usage_in_kernelmode",
                    |m: &CpuUsage| { &m.usage_in_kernelmode },
                    |m: &mut CpuUsage| { &mut m.usage_in_kernelmode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "usage_in_usermode",
                    |m: &CpuUsage| { &m.usage_in_usermode },
                    |m: &mut CpuUsage| { &mut m.usage_in_usermode },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CpuUsage>(
                    "CpuUsage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CpuUsage {
        static mut instance: ::protobuf::lazy::Lazy<CpuUsage> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CpuUsage::new)
        }
    }
}

impl ::protobuf::Clear for CpuUsage {
    fn clear(&mut self) {
        self.total_usage = 0;
        self.percpu_usage.clear();
        self.usage_in_kernelmode = 0;
        self.usage_in_usermode = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CpuUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpuUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThrottlingData {
    // message fields
    pub periods: u64,
    pub throttled_periods: u64,
    pub throttled_time: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThrottlingData {
    fn default() -> &'a ThrottlingData {
        <ThrottlingData as ::protobuf::Message>::default_instance()
    }
}

impl ThrottlingData {
    pub fn new() -> ThrottlingData {
        ::std::default::Default::default()
    }

    // uint64 periods = 1;


    pub fn get_periods(&self) -> u64 {
        self.periods
    }
    pub fn clear_periods(&mut self) {
        self.periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_periods(&mut self, v: u64) {
        self.periods = v;
    }

    // uint64 throttled_periods = 2;


    pub fn get_throttled_periods(&self) -> u64 {
        self.throttled_periods
    }
    pub fn clear_throttled_periods(&mut self) {
        self.throttled_periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_periods(&mut self, v: u64) {
        self.throttled_periods = v;
    }

    // uint64 throttled_time = 3;


    pub fn get_throttled_time(&self) -> u64 {
        self.throttled_time
    }
    pub fn clear_throttled_time(&mut self) {
        self.throttled_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_time(&mut self, v: u64) {
        self.throttled_time = v;
    }
}

impl ::protobuf::Message for ThrottlingData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.periods = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.throttled_periods = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.throttled_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.periods != 0 {
            my_size += ::protobuf::rt::value_size(1, self.periods, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.throttled_periods != 0 {
            my_size += ::protobuf::rt::value_size(2, self.throttled_periods, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.throttled_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.throttled_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.periods != 0 {
            os.write_uint64(1, self.periods)?;
        }
        if self.throttled_periods != 0 {
            os.write_uint64(2, self.throttled_periods)?;
        }
        if self.throttled_time != 0 {
            os.write_uint64(3, self.throttled_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThrottlingData {
        ThrottlingData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "periods",
                    |m: &ThrottlingData| { &m.periods },
                    |m: &mut ThrottlingData| { &mut m.periods },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "throttled_periods",
                    |m: &ThrottlingData| { &m.throttled_periods },
                    |m: &mut ThrottlingData| { &mut m.throttled_periods },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "throttled_time",
                    |m: &ThrottlingData| { &m.throttled_time },
                    |m: &mut ThrottlingData| { &mut m.throttled_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ThrottlingData>(
                    "ThrottlingData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThrottlingData {
        static mut instance: ::protobuf::lazy::Lazy<ThrottlingData> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ThrottlingData::new)
        }
    }
}

impl ::protobuf::Clear for ThrottlingData {
    fn clear(&mut self) {
        self.periods = 0;
        self.throttled_periods = 0;
        self.throttled_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThrottlingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThrottlingData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CpuStats {
    // message fields
    pub cpu_usage: ::protobuf::SingularPtrField<CpuUsage>,
    pub throttling_data: ::protobuf::SingularPtrField<ThrottlingData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CpuStats {
    fn default() -> &'a CpuStats {
        <CpuStats as ::protobuf::Message>::default_instance()
    }
}

impl CpuStats {
    pub fn new() -> CpuStats {
        ::std::default::Default::default()
    }

    // .grpc.CpuUsage cpu_usage = 1;


    pub fn get_cpu_usage(&self) -> &CpuUsage {
        self.cpu_usage.as_ref().unwrap_or_else(|| CpuUsage::default_instance())
    }
    pub fn clear_cpu_usage(&mut self) {
        self.cpu_usage.clear();
    }

    pub fn has_cpu_usage(&self) -> bool {
        self.cpu_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_usage(&mut self, v: CpuUsage) {
        self.cpu_usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_usage(&mut self) -> &mut CpuUsage {
        if self.cpu_usage.is_none() {
            self.cpu_usage.set_default();
        }
        self.cpu_usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_usage(&mut self) -> CpuUsage {
        self.cpu_usage.take().unwrap_or_else(|| CpuUsage::new())
    }

    // .grpc.ThrottlingData throttling_data = 2;


    pub fn get_throttling_data(&self) -> &ThrottlingData {
        self.throttling_data.as_ref().unwrap_or_else(|| ThrottlingData::default_instance())
    }
    pub fn clear_throttling_data(&mut self) {
        self.throttling_data.clear();
    }

    pub fn has_throttling_data(&self) -> bool {
        self.throttling_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_data(&mut self, v: ThrottlingData) {
        self.throttling_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_throttling_data(&mut self) -> &mut ThrottlingData {
        if self.throttling_data.is_none() {
            self.throttling_data.set_default();
        }
        self.throttling_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_throttling_data(&mut self) -> ThrottlingData {
        self.throttling_data.take().unwrap_or_else(|| ThrottlingData::new())
    }
}

impl ::protobuf::Message for CpuStats {
    fn is_initialized(&self) -> bool {
        for v in &self.cpu_usage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.throttling_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu_usage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.throttling_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cpu_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.throttling_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cpu_usage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.throttling_data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CpuStats {
        CpuStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CpuUsage>>(
                    "cpu_usage",
                    |m: &CpuStats| { &m.cpu_usage },
                    |m: &mut CpuStats| { &mut m.cpu_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ThrottlingData>>(
                    "throttling_data",
                    |m: &CpuStats| { &m.throttling_data },
                    |m: &mut CpuStats| { &mut m.throttling_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CpuStats>(
                    "CpuStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CpuStats {
        static mut instance: ::protobuf::lazy::Lazy<CpuStats> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CpuStats::new)
        }
    }
}

impl ::protobuf::Clear for CpuStats {
    fn clear(&mut self) {
        self.cpu_usage.clear();
        self.throttling_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CpuStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpuStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PidsStats {
    // message fields
    pub current: u64,
    pub limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PidsStats {
    fn default() -> &'a PidsStats {
        <PidsStats as ::protobuf::Message>::default_instance()
    }
}

impl PidsStats {
    pub fn new() -> PidsStats {
        ::std::default::Default::default()
    }

    // uint64 current = 1;


    pub fn get_current(&self) -> u64 {
        self.current
    }
    pub fn clear_current(&mut self) {
        self.current = 0;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: u64) {
        self.current = v;
    }

    // uint64 limit = 2;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for PidsStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.current != 0 {
            my_size += ::protobuf::rt::value_size(1, self.current, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.current != 0 {
            os.write_uint64(1, self.current)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PidsStats {
        PidsStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "current",
                    |m: &PidsStats| { &m.current },
                    |m: &mut PidsStats| { &mut m.current },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &PidsStats| { &m.limit },
                    |m: &mut PidsStats| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PidsStats>(
                    "PidsStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PidsStats {
        static mut instance: ::protobuf::lazy::Lazy<PidsStats> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PidsStats::new)
        }
    }
}

impl ::protobuf::Clear for PidsStats {
    fn clear(&mut self) {
        self.current = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PidsStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PidsStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemoryData {
    // message fields
    pub usage: u64,
    pub max_usage: u64,
    pub failcnt: u64,
    pub limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemoryData {
    fn default() -> &'a MemoryData {
        <MemoryData as ::protobuf::Message>::default_instance()
    }
}

impl MemoryData {
    pub fn new() -> MemoryData {
        ::std::default::Default::default()
    }

    // uint64 usage = 1;


    pub fn get_usage(&self) -> u64 {
        self.usage
    }
    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max_usage = 2;


    pub fn get_max_usage(&self) -> u64 {
        self.max_usage
    }
    pub fn clear_max_usage(&mut self) {
        self.max_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_usage(&mut self, v: u64) {
        self.max_usage = v;
    }

    // uint64 failcnt = 3;


    pub fn get_failcnt(&self) -> u64 {
        self.failcnt
    }
    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }

    // uint64 limit = 4;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for MemoryData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_usage = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.failcnt = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_usage != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.failcnt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.usage != 0 {
            os.write_uint64(1, self.usage)?;
        }
        if self.max_usage != 0 {
            os.write_uint64(2, self.max_usage)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(3, self.failcnt)?;
        }
        if self.limit != 0 {
            os.write_uint64(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemoryData {
        MemoryData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "usage",
                    |m: &MemoryData| { &m.usage },
                    |m: &mut MemoryData| { &mut m.usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "max_usage",
                    |m: &MemoryData| { &m.max_usage },
                    |m: &mut MemoryData| { &mut m.max_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "failcnt",
                    |m: &MemoryData| { &m.failcnt },
                    |m: &mut MemoryData| { &mut m.failcnt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &MemoryData| { &m.limit },
                    |m: &mut MemoryData| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemoryData>(
                    "MemoryData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemoryData {
        static mut instance: ::protobuf::lazy::Lazy<MemoryData> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MemoryData::new)
        }
    }
}

impl ::protobuf::Clear for MemoryData {
    fn clear(&mut self) {
        self.usage = 0;
        self.max_usage = 0;
        self.failcnt = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemoryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemoryStats {
    // message fields
    pub cache: u64,
    pub usage: ::protobuf::SingularPtrField<MemoryData>,
    pub swap_usage: ::protobuf::SingularPtrField<MemoryData>,
    pub kernel_usage: ::protobuf::SingularPtrField<MemoryData>,
    pub use_hierarchy: bool,
    pub stats: ::std::collections::HashMap<::std::string::String, u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemoryStats {
    fn default() -> &'a MemoryStats {
        <MemoryStats as ::protobuf::Message>::default_instance()
    }
}

impl MemoryStats {
    pub fn new() -> MemoryStats {
        ::std::default::Default::default()
    }

    // uint64 cache = 1;


    pub fn get_cache(&self) -> u64 {
        self.cache
    }
    pub fn clear_cache(&mut self) {
        self.cache = 0;
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: u64) {
        self.cache = v;
    }

    // .grpc.MemoryData usage = 2;


    pub fn get_usage(&self) -> &MemoryData {
        self.usage.as_ref().unwrap_or_else(|| MemoryData::default_instance())
    }
    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: MemoryData) {
        self.usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut MemoryData {
        if self.usage.is_none() {
            self.usage.set_default();
        }
        self.usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_usage(&mut self) -> MemoryData {
        self.usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // .grpc.MemoryData swap_usage = 3;


    pub fn get_swap_usage(&self) -> &MemoryData {
        self.swap_usage.as_ref().unwrap_or_else(|| MemoryData::default_instance())
    }
    pub fn clear_swap_usage(&mut self) {
        self.swap_usage.clear();
    }

    pub fn has_swap_usage(&self) -> bool {
        self.swap_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap_usage(&mut self, v: MemoryData) {
        self.swap_usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swap_usage(&mut self) -> &mut MemoryData {
        if self.swap_usage.is_none() {
            self.swap_usage.set_default();
        }
        self.swap_usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_swap_usage(&mut self) -> MemoryData {
        self.swap_usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // .grpc.MemoryData kernel_usage = 4;


    pub fn get_kernel_usage(&self) -> &MemoryData {
        self.kernel_usage.as_ref().unwrap_or_else(|| MemoryData::default_instance())
    }
    pub fn clear_kernel_usage(&mut self) {
        self.kernel_usage.clear();
    }

    pub fn has_kernel_usage(&self) -> bool {
        self.kernel_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel_usage(&mut self, v: MemoryData) {
        self.kernel_usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel_usage(&mut self) -> &mut MemoryData {
        if self.kernel_usage.is_none() {
            self.kernel_usage.set_default();
        }
        self.kernel_usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernel_usage(&mut self) -> MemoryData {
        self.kernel_usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // bool use_hierarchy = 5;


    pub fn get_use_hierarchy(&self) -> bool {
        self.use_hierarchy
    }
    pub fn clear_use_hierarchy(&mut self) {
        self.use_hierarchy = false;
    }

    // Param is passed by value, moved
    pub fn set_use_hierarchy(&mut self, v: bool) {
        self.use_hierarchy = v;
    }

    // repeated .grpc.MemoryStats.stats_MapEntry stats = 6;


    pub fn get_stats(&self) -> &::std::collections::HashMap<::std::string::String, u64> {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::collections::HashMap<::std::string::String, u64>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u64> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::collections::HashMap<::std::string::String, u64> {
        ::std::mem::replace(&mut self.stats, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for MemoryStats {
    fn is_initialized(&self) -> bool {
        for v in &self.usage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.swap_usage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kernel_usage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cache = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.swap_usage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kernel_usage)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_hierarchy = tmp;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cache != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cache, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.swap_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kernel_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.use_hierarchy != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(6, &self.stats);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cache != 0 {
            os.write_uint64(1, self.cache)?;
        }
        if let Some(ref v) = self.usage.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.swap_usage.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kernel_usage.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.use_hierarchy != false {
            os.write_bool(5, self.use_hierarchy)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(6, &self.stats, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemoryStats {
        MemoryStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cache",
                    |m: &MemoryStats| { &m.cache },
                    |m: &mut MemoryStats| { &mut m.cache },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryData>>(
                    "usage",
                    |m: &MemoryStats| { &m.usage },
                    |m: &mut MemoryStats| { &mut m.usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryData>>(
                    "swap_usage",
                    |m: &MemoryStats| { &m.swap_usage },
                    |m: &mut MemoryStats| { &mut m.swap_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryData>>(
                    "kernel_usage",
                    |m: &MemoryStats| { &m.kernel_usage },
                    |m: &mut MemoryStats| { &mut m.kernel_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_hierarchy",
                    |m: &MemoryStats| { &m.use_hierarchy },
                    |m: &mut MemoryStats| { &mut m.use_hierarchy },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(
                    "stats",
                    |m: &MemoryStats| { &m.stats },
                    |m: &mut MemoryStats| { &mut m.stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemoryStats>(
                    "MemoryStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemoryStats {
        static mut instance: ::protobuf::lazy::Lazy<MemoryStats> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MemoryStats::new)
        }
    }
}

impl ::protobuf::Clear for MemoryStats {
    fn clear(&mut self) {
        self.cache = 0;
        self.usage.clear();
        self.swap_usage.clear();
        self.kernel_usage.clear();
        self.use_hierarchy = false;
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemoryStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlkioStatsEntry {
    // message fields
    pub major: u64,
    pub minor: u64,
    pub op: ::std::string::String,
    pub value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlkioStatsEntry {
    fn default() -> &'a BlkioStatsEntry {
        <BlkioStatsEntry as ::protobuf::Message>::default_instance()
    }
}

impl BlkioStatsEntry {
    pub fn new() -> BlkioStatsEntry {
        ::std::default::Default::default()
    }

    // uint64 major = 1;


    pub fn get_major(&self) -> u64 {
        self.major
    }
    pub fn clear_major(&mut self) {
        self.major = 0;
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: u64) {
        self.major = v;
    }

    // uint64 minor = 2;


    pub fn get_minor(&self) -> u64 {
        self.minor
    }
    pub fn clear_minor(&mut self) {
        self.minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u64) {
        self.minor = v;
    }

    // string op = 3;


    pub fn get_op(&self) -> &str {
        &self.op
    }
    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::std::string::String) {
        self.op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut ::std::string::String {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op, ::std::string::String::new())
    }

    // uint64 value = 4;


    pub fn get_value(&self) -> u64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }
}

impl ::protobuf::Message for BlkioStatsEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.major = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minor = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.major != 0 {
            my_size += ::protobuf::rt::value_size(1, self.major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.minor != 0 {
            my_size += ::protobuf::rt::value_size(2, self.minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.op);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(4, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.major != 0 {
            os.write_uint64(1, self.major)?;
        }
        if self.minor != 0 {
            os.write_uint64(2, self.minor)?;
        }
        if !self.op.is_empty() {
            os.write_string(3, &self.op)?;
        }
        if self.value != 0 {
            os.write_uint64(4, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlkioStatsEntry {
        BlkioStatsEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "major",
                    |m: &BlkioStatsEntry| { &m.major },
                    |m: &mut BlkioStatsEntry| { &mut m.major },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minor",
                    |m: &BlkioStatsEntry| { &m.minor },
                    |m: &mut BlkioStatsEntry| { &mut m.minor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "op",
                    |m: &BlkioStatsEntry| { &m.op },
                    |m: &mut BlkioStatsEntry| { &mut m.op },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    |m: &BlkioStatsEntry| { &m.value },
                    |m: &mut BlkioStatsEntry| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlkioStatsEntry>(
                    "BlkioStatsEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlkioStatsEntry {
        static mut instance: ::protobuf::lazy::Lazy<BlkioStatsEntry> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BlkioStatsEntry::new)
        }
    }
}

impl ::protobuf::Clear for BlkioStatsEntry {
    fn clear(&mut self) {
        self.major = 0;
        self.minor = 0;
        self.op.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlkioStatsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkioStatsEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlkioStats {
    // message fields
    pub io_service_bytes_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_serviced_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_queued_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_service_time_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_wait_time_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_merged_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_time_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub sectors_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlkioStats {
    fn default() -> &'a BlkioStats {
        <BlkioStats as ::protobuf::Message>::default_instance()
    }
}

impl BlkioStats {
    pub fn new() -> BlkioStats {
        ::std::default::Default::default()
    }

    // repeated .grpc.BlkioStatsEntry io_service_bytes_recursive = 1;


    pub fn get_io_service_bytes_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_service_bytes_recursive
    }
    pub fn clear_io_service_bytes_recursive(&mut self) {
        self.io_service_bytes_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_bytes_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_service_bytes_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_bytes_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_service_bytes_recursive
    }

    // Take field
    pub fn take_io_service_bytes_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_service_bytes_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_serviced_recursive = 2;


    pub fn get_io_serviced_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_serviced_recursive
    }
    pub fn clear_io_serviced_recursive(&mut self) {
        self.io_serviced_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_serviced_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_serviced_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_serviced_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_serviced_recursive
    }

    // Take field
    pub fn take_io_serviced_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_serviced_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_queued_recursive = 3;


    pub fn get_io_queued_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_queued_recursive
    }
    pub fn clear_io_queued_recursive(&mut self) {
        self.io_queued_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_queued_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_queued_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_queued_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_queued_recursive
    }

    // Take field
    pub fn take_io_queued_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_queued_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_service_time_recursive = 4;


    pub fn get_io_service_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_service_time_recursive
    }
    pub fn clear_io_service_time_recursive(&mut self) {
        self.io_service_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_service_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_service_time_recursive
    }

    // Take field
    pub fn take_io_service_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_service_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_wait_time_recursive = 5;


    pub fn get_io_wait_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_wait_time_recursive
    }
    pub fn clear_io_wait_time_recursive(&mut self) {
        self.io_wait_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_wait_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_wait_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_wait_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_wait_time_recursive
    }

    // Take field
    pub fn take_io_wait_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_wait_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_merged_recursive = 6;


    pub fn get_io_merged_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_merged_recursive
    }
    pub fn clear_io_merged_recursive(&mut self) {
        self.io_merged_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_merged_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_merged_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_merged_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_merged_recursive
    }

    // Take field
    pub fn take_io_merged_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_merged_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_time_recursive = 7;


    pub fn get_io_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_time_recursive
    }
    pub fn clear_io_time_recursive(&mut self) {
        self.io_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_time_recursive
    }

    // Take field
    pub fn take_io_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry sectors_recursive = 8;


    pub fn get_sectors_recursive(&self) -> &[BlkioStatsEntry] {
        &self.sectors_recursive
    }
    pub fn clear_sectors_recursive(&mut self) {
        self.sectors_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_sectors_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.sectors_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sectors_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.sectors_recursive
    }

    // Take field
    pub fn take_sectors_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.sectors_recursive, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlkioStats {
    fn is_initialized(&self) -> bool {
        for v in &self.io_service_bytes_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_serviced_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_queued_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_service_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_wait_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_merged_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectors_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_bytes_recursive)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_serviced_recursive)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_queued_recursive)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_time_recursive)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_wait_time_recursive)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_merged_recursive)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_time_recursive)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sectors_recursive)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.io_service_bytes_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_serviced_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_queued_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_service_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_wait_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_merged_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sectors_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.io_service_bytes_recursive {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_serviced_recursive {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_queued_recursive {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_service_time_recursive {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_wait_time_recursive {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_merged_recursive {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_time_recursive {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sectors_recursive {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlkioStats {
        BlkioStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_service_bytes_recursive",
                    |m: &BlkioStats| { &m.io_service_bytes_recursive },
                    |m: &mut BlkioStats| { &mut m.io_service_bytes_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_serviced_recursive",
                    |m: &BlkioStats| { &m.io_serviced_recursive },
                    |m: &mut BlkioStats| { &mut m.io_serviced_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_queued_recursive",
                    |m: &BlkioStats| { &m.io_queued_recursive },
                    |m: &mut BlkioStats| { &mut m.io_queued_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_service_time_recursive",
                    |m: &BlkioStats| { &m.io_service_time_recursive },
                    |m: &mut BlkioStats| { &mut m.io_service_time_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_wait_time_recursive",
                    |m: &BlkioStats| { &m.io_wait_time_recursive },
                    |m: &mut BlkioStats| { &mut m.io_wait_time_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_merged_recursive",
                    |m: &BlkioStats| { &m.io_merged_recursive },
                    |m: &mut BlkioStats| { &mut m.io_merged_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_time_recursive",
                    |m: &BlkioStats| { &m.io_time_recursive },
                    |m: &mut BlkioStats| { &mut m.io_time_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "sectors_recursive",
                    |m: &BlkioStats| { &m.sectors_recursive },
                    |m: &mut BlkioStats| { &mut m.sectors_recursive },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlkioStats>(
                    "BlkioStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlkioStats {
        static mut instance: ::protobuf::lazy::Lazy<BlkioStats> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BlkioStats::new)
        }
    }
}

impl ::protobuf::Clear for BlkioStats {
    fn clear(&mut self) {
        self.io_service_bytes_recursive.clear();
        self.io_serviced_recursive.clear();
        self.io_queued_recursive.clear();
        self.io_service_time_recursive.clear();
        self.io_wait_time_recursive.clear();
        self.io_merged_recursive.clear();
        self.io_time_recursive.clear();
        self.sectors_recursive.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlkioStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkioStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HugetlbStats {
    // message fields
    pub usage: u64,
    pub max_usage: u64,
    pub failcnt: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HugetlbStats {
    fn default() -> &'a HugetlbStats {
        <HugetlbStats as ::protobuf::Message>::default_instance()
    }
}

impl HugetlbStats {
    pub fn new() -> HugetlbStats {
        ::std::default::Default::default()
    }

    // uint64 usage = 1;


    pub fn get_usage(&self) -> u64 {
        self.usage
    }
    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max_usage = 2;


    pub fn get_max_usage(&self) -> u64 {
        self.max_usage
    }
    pub fn clear_max_usage(&mut self) {
        self.max_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_usage(&mut self, v: u64) {
        self.max_usage = v;
    }

    // uint64 failcnt = 3;


    pub fn get_failcnt(&self) -> u64 {
        self.failcnt
    }
    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }
}

impl ::protobuf::Message for HugetlbStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_usage = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.failcnt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_usage != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.failcnt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.usage != 0 {
            os.write_uint64(1, self.usage)?;
        }
        if self.max_usage != 0 {
            os.write_uint64(2, self.max_usage)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(3, self.failcnt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HugetlbStats {
        HugetlbStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "usage",
                    |m: &HugetlbStats| { &m.usage },
                    |m: &mut HugetlbStats| { &mut m.usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "max_usage",
                    |m: &HugetlbStats| { &m.max_usage },
                    |m: &mut HugetlbStats| { &mut m.max_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "failcnt",
                    |m: &HugetlbStats| { &m.failcnt },
                    |m: &mut HugetlbStats| { &mut m.failcnt },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HugetlbStats>(
                    "HugetlbStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HugetlbStats {
        static mut instance: ::protobuf::lazy::Lazy<HugetlbStats> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HugetlbStats::new)
        }
    }
}

impl ::protobuf::Clear for HugetlbStats {
    fn clear(&mut self) {
        self.usage = 0;
        self.max_usage = 0;
        self.failcnt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HugetlbStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HugetlbStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupStats {
    // message fields
    pub cpu_stats: ::protobuf::SingularPtrField<CpuStats>,
    pub memory_stats: ::protobuf::SingularPtrField<MemoryStats>,
    pub pids_stats: ::protobuf::SingularPtrField<PidsStats>,
    pub blkio_stats: ::protobuf::SingularPtrField<BlkioStats>,
    pub hugetlb_stats: ::std::collections::HashMap<::std::string::String, HugetlbStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CgroupStats {
    fn default() -> &'a CgroupStats {
        <CgroupStats as ::protobuf::Message>::default_instance()
    }
}

impl CgroupStats {
    pub fn new() -> CgroupStats {
        ::std::default::Default::default()
    }

    // .grpc.CpuStats cpu_stats = 1;


    pub fn get_cpu_stats(&self) -> &CpuStats {
        self.cpu_stats.as_ref().unwrap_or_else(|| CpuStats::default_instance())
    }
    pub fn clear_cpu_stats(&mut self) {
        self.cpu_stats.clear();
    }

    pub fn has_cpu_stats(&self) -> bool {
        self.cpu_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_stats(&mut self, v: CpuStats) {
        self.cpu_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_stats(&mut self) -> &mut CpuStats {
        if self.cpu_stats.is_none() {
            self.cpu_stats.set_default();
        }
        self.cpu_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_stats(&mut self) -> CpuStats {
        self.cpu_stats.take().unwrap_or_else(|| CpuStats::new())
    }

    // .grpc.MemoryStats memory_stats = 2;


    pub fn get_memory_stats(&self) -> &MemoryStats {
        self.memory_stats.as_ref().unwrap_or_else(|| MemoryStats::default_instance())
    }
    pub fn clear_memory_stats(&mut self) {
        self.memory_stats.clear();
    }

    pub fn has_memory_stats(&self) -> bool {
        self.memory_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_stats(&mut self, v: MemoryStats) {
        self.memory_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory_stats(&mut self) -> &mut MemoryStats {
        if self.memory_stats.is_none() {
            self.memory_stats.set_default();
        }
        self.memory_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory_stats(&mut self) -> MemoryStats {
        self.memory_stats.take().unwrap_or_else(|| MemoryStats::new())
    }

    // .grpc.PidsStats pids_stats = 3;


    pub fn get_pids_stats(&self) -> &PidsStats {
        self.pids_stats.as_ref().unwrap_or_else(|| PidsStats::default_instance())
    }
    pub fn clear_pids_stats(&mut self) {
        self.pids_stats.clear();
    }

    pub fn has_pids_stats(&self) -> bool {
        self.pids_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pids_stats(&mut self, v: PidsStats) {
        self.pids_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pids_stats(&mut self) -> &mut PidsStats {
        if self.pids_stats.is_none() {
            self.pids_stats.set_default();
        }
        self.pids_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_pids_stats(&mut self) -> PidsStats {
        self.pids_stats.take().unwrap_or_else(|| PidsStats::new())
    }

    // .grpc.BlkioStats blkio_stats = 4;


    pub fn get_blkio_stats(&self) -> &BlkioStats {
        self.blkio_stats.as_ref().unwrap_or_else(|| BlkioStats::default_instance())
    }
    pub fn clear_blkio_stats(&mut self) {
        self.blkio_stats.clear();
    }

    pub fn has_blkio_stats(&self) -> bool {
        self.blkio_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkio_stats(&mut self, v: BlkioStats) {
        self.blkio_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkio_stats(&mut self) -> &mut BlkioStats {
        if self.blkio_stats.is_none() {
            self.blkio_stats.set_default();
        }
        self.blkio_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_blkio_stats(&mut self) -> BlkioStats {
        self.blkio_stats.take().unwrap_or_else(|| BlkioStats::new())
    }

    // repeated .grpc.CgroupStats.hugetlb_stats_MapEntry hugetlb_stats = 5;


    pub fn get_hugetlb_stats(&self) -> &::std::collections::HashMap<::std::string::String, HugetlbStats> {
        &self.hugetlb_stats
    }
    pub fn clear_hugetlb_stats(&mut self) {
        self.hugetlb_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_hugetlb_stats(&mut self, v: ::std::collections::HashMap<::std::string::String, HugetlbStats>) {
        self.hugetlb_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hugetlb_stats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, HugetlbStats> {
        &mut self.hugetlb_stats
    }

    // Take field
    pub fn take_hugetlb_stats(&mut self) -> ::std::collections::HashMap<::std::string::String, HugetlbStats> {
        ::std::mem::replace(&mut self.hugetlb_stats, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for CgroupStats {
    fn is_initialized(&self) -> bool {
        for v in &self.cpu_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memory_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pids_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blkio_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu_stats)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory_stats)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pids_stats)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blkio_stats)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<HugetlbStats>>(wire_type, is, &mut self.hugetlb_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cpu_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memory_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pids_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blkio_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<HugetlbStats>>(5, &self.hugetlb_stats);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cpu_stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memory_stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pids_stats.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blkio_stats.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<HugetlbStats>>(5, &self.hugetlb_stats, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CgroupStats {
        CgroupStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CpuStats>>(
                    "cpu_stats",
                    |m: &CgroupStats| { &m.cpu_stats },
                    |m: &mut CgroupStats| { &mut m.cpu_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryStats>>(
                    "memory_stats",
                    |m: &CgroupStats| { &m.memory_stats },
                    |m: &mut CgroupStats| { &mut m.memory_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PidsStats>>(
                    "pids_stats",
                    |m: &CgroupStats| { &m.pids_stats },
                    |m: &mut CgroupStats| { &mut m.pids_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStats>>(
                    "blkio_stats",
                    |m: &CgroupStats| { &m.blkio_stats },
                    |m: &mut CgroupStats| { &mut m.blkio_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<HugetlbStats>>(
                    "hugetlb_stats",
                    |m: &CgroupStats| { &m.hugetlb_stats },
                    |m: &mut CgroupStats| { &mut m.hugetlb_stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CgroupStats>(
                    "CgroupStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CgroupStats {
        static mut instance: ::protobuf::lazy::Lazy<CgroupStats> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CgroupStats::new)
        }
    }
}

impl ::protobuf::Clear for CgroupStats {
    fn clear(&mut self) {
        self.cpu_stats.clear();
        self.memory_stats.clear();
        self.pids_stats.clear();
        self.blkio_stats.clear();
        self.hugetlb_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkStats {
    // message fields
    pub name: ::std::string::String,
    pub rx_bytes: u64,
    pub rx_packets: u64,
    pub rx_errors: u64,
    pub rx_dropped: u64,
    pub tx_bytes: u64,
    pub tx_packets: u64,
    pub tx_errors: u64,
    pub tx_dropped: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkStats {
    fn default() -> &'a NetworkStats {
        <NetworkStats as ::protobuf::Message>::default_instance()
    }
}

impl NetworkStats {
    pub fn new() -> NetworkStats {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 rx_bytes = 2;


    pub fn get_rx_bytes(&self) -> u64 {
        self.rx_bytes
    }
    pub fn clear_rx_bytes(&mut self) {
        self.rx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes(&mut self, v: u64) {
        self.rx_bytes = v;
    }

    // uint64 rx_packets = 3;


    pub fn get_rx_packets(&self) -> u64 {
        self.rx_packets
    }
    pub fn clear_rx_packets(&mut self) {
        self.rx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_packets(&mut self, v: u64) {
        self.rx_packets = v;
    }

    // uint64 rx_errors = 4;


    pub fn get_rx_errors(&self) -> u64 {
        self.rx_errors
    }
    pub fn clear_rx_errors(&mut self) {
        self.rx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_errors(&mut self, v: u64) {
        self.rx_errors = v;
    }

    // uint64 rx_dropped = 5;


    pub fn get_rx_dropped(&self) -> u64 {
        self.rx_dropped
    }
    pub fn clear_rx_dropped(&mut self) {
        self.rx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_dropped(&mut self, v: u64) {
        self.rx_dropped = v;
    }

    // uint64 tx_bytes = 6;


    pub fn get_tx_bytes(&self) -> u64 {
        self.tx_bytes
    }
    pub fn clear_tx_bytes(&mut self) {
        self.tx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes(&mut self, v: u64) {
        self.tx_bytes = v;
    }

    // uint64 tx_packets = 7;


    pub fn get_tx_packets(&self) -> u64 {
        self.tx_packets
    }
    pub fn clear_tx_packets(&mut self) {
        self.tx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_packets(&mut self, v: u64) {
        self.tx_packets = v;
    }

    // uint64 tx_errors = 8;


    pub fn get_tx_errors(&self) -> u64 {
        self.tx_errors
    }
    pub fn clear_tx_errors(&mut self) {
        self.tx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_errors(&mut self, v: u64) {
        self.tx_errors = v;
    }

    // uint64 tx_dropped = 9;


    pub fn get_tx_dropped(&self) -> u64 {
        self.tx_dropped
    }
    pub fn clear_tx_dropped(&mut self) {
        self.tx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_dropped(&mut self, v: u64) {
        self.tx_dropped = v;
    }
}

impl ::protobuf::Message for NetworkStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_bytes = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_packets = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_errors = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_dropped = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_bytes = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_packets = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_errors = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_dropped = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.rx_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.rx_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_packets != 0 {
            my_size += ::protobuf::rt::value_size(3, self.rx_packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_errors != 0 {
            my_size += ::protobuf::rt::value_size(4, self.rx_errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_dropped != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rx_dropped, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_bytes != 0 {
            my_size += ::protobuf::rt::value_size(6, self.tx_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_packets != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tx_packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_errors != 0 {
            my_size += ::protobuf::rt::value_size(8, self.tx_errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_dropped != 0 {
            my_size += ::protobuf::rt::value_size(9, self.tx_dropped, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.rx_bytes != 0 {
            os.write_uint64(2, self.rx_bytes)?;
        }
        if self.rx_packets != 0 {
            os.write_uint64(3, self.rx_packets)?;
        }
        if self.rx_errors != 0 {
            os.write_uint64(4, self.rx_errors)?;
        }
        if self.rx_dropped != 0 {
            os.write_uint64(5, self.rx_dropped)?;
        }
        if self.tx_bytes != 0 {
            os.write_uint64(6, self.tx_bytes)?;
        }
        if self.tx_packets != 0 {
            os.write_uint64(7, self.tx_packets)?;
        }
        if self.tx_errors != 0 {
            os.write_uint64(8, self.tx_errors)?;
        }
        if self.tx_dropped != 0 {
            os.write_uint64(9, self.tx_dropped)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkStats {
        NetworkStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NetworkStats| { &m.name },
                    |m: &mut NetworkStats| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rx_bytes",
                    |m: &NetworkStats| { &m.rx_bytes },
                    |m: &mut NetworkStats| { &mut m.rx_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rx_packets",
                    |m: &NetworkStats| { &m.rx_packets },
                    |m: &mut NetworkStats| { &mut m.rx_packets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rx_errors",
                    |m: &NetworkStats| { &m.rx_errors },
                    |m: &mut NetworkStats| { &mut m.rx_errors },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rx_dropped",
                    |m: &NetworkStats| { &m.rx_dropped },
                    |m: &mut NetworkStats| { &mut m.rx_dropped },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_bytes",
                    |m: &NetworkStats| { &m.tx_bytes },
                    |m: &mut NetworkStats| { &mut m.tx_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_packets",
                    |m: &NetworkStats| { &m.tx_packets },
                    |m: &mut NetworkStats| { &mut m.tx_packets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_errors",
                    |m: &NetworkStats| { &m.tx_errors },
                    |m: &mut NetworkStats| { &mut m.tx_errors },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_dropped",
                    |m: &NetworkStats| { &m.tx_dropped },
                    |m: &mut NetworkStats| { &mut m.tx_dropped },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkStats>(
                    "NetworkStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NetworkStats {
        static mut instance: ::protobuf::lazy::Lazy<NetworkStats> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(NetworkStats::new)
        }
    }
}

impl ::protobuf::Clear for NetworkStats {
    fn clear(&mut self) {
        self.name.clear();
        self.rx_bytes = 0;
        self.rx_packets = 0;
        self.rx_errors = 0;
        self.rx_dropped = 0;
        self.tx_bytes = 0;
        self.tx_packets = 0;
        self.tx_errors = 0;
        self.tx_dropped = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatsContainerResponse {
    // message fields
    pub cgroup_stats: ::protobuf::SingularPtrField<CgroupStats>,
    pub network_stats: ::protobuf::RepeatedField<NetworkStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatsContainerResponse {
    fn default() -> &'a StatsContainerResponse {
        <StatsContainerResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatsContainerResponse {
    pub fn new() -> StatsContainerResponse {
        ::std::default::Default::default()
    }

    // .grpc.CgroupStats cgroup_stats = 1;


    pub fn get_cgroup_stats(&self) -> &CgroupStats {
        self.cgroup_stats.as_ref().unwrap_or_else(|| CgroupStats::default_instance())
    }
    pub fn clear_cgroup_stats(&mut self) {
        self.cgroup_stats.clear();
    }

    pub fn has_cgroup_stats(&self) -> bool {
        self.cgroup_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cgroup_stats(&mut self, v: CgroupStats) {
        self.cgroup_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cgroup_stats(&mut self) -> &mut CgroupStats {
        if self.cgroup_stats.is_none() {
            self.cgroup_stats.set_default();
        }
        self.cgroup_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_cgroup_stats(&mut self) -> CgroupStats {
        self.cgroup_stats.take().unwrap_or_else(|| CgroupStats::new())
    }

    // repeated .grpc.NetworkStats network_stats = 2;


    pub fn get_network_stats(&self) -> &[NetworkStats] {
        &self.network_stats
    }
    pub fn clear_network_stats(&mut self) {
        self.network_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_network_stats(&mut self, v: ::protobuf::RepeatedField<NetworkStats>) {
        self.network_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network_stats(&mut self) -> &mut ::protobuf::RepeatedField<NetworkStats> {
        &mut self.network_stats
    }

    // Take field
    pub fn take_network_stats(&mut self) -> ::protobuf::RepeatedField<NetworkStats> {
        ::std::mem::replace(&mut self.network_stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StatsContainerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.cgroup_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cgroup_stats)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.network_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cgroup_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.network_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cgroup_stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.network_stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatsContainerResponse {
        StatsContainerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupStats>>(
                    "cgroup_stats",
                    |m: &StatsContainerResponse| { &m.cgroup_stats },
                    |m: &mut StatsContainerResponse| { &mut m.cgroup_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkStats>>(
                    "network_stats",
                    |m: &StatsContainerResponse| { &m.network_stats },
                    |m: &mut StatsContainerResponse| { &mut m.network_stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatsContainerResponse>(
                    "StatsContainerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatsContainerResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatsContainerResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StatsContainerResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatsContainerResponse {
    fn clear(&mut self) {
        self.cgroup_stats.clear();
        self.network_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatsContainerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsContainerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteStreamRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteStreamRequest {
    fn default() -> &'a WriteStreamRequest {
        <WriteStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteStreamRequest {
    pub fn new() -> WriteStreamRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WriteStreamRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteStreamRequest {
        WriteStreamRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &WriteStreamRequest| { &m.container_id },
                    |m: &mut WriteStreamRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &WriteStreamRequest| { &m.exec_id },
                    |m: &mut WriteStreamRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &WriteStreamRequest| { &m.data },
                    |m: &mut WriteStreamRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteStreamRequest>(
                    "WriteStreamRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteStreamRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteStreamRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WriteStreamRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteStreamRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteStreamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteStreamResponse {
    // message fields
    pub len: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteStreamResponse {
    fn default() -> &'a WriteStreamResponse {
        <WriteStreamResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteStreamResponse {
    pub fn new() -> WriteStreamResponse {
        ::std::default::Default::default()
    }

    // uint32 len = 1;


    pub fn get_len(&self) -> u32 {
        self.len
    }
    pub fn clear_len(&mut self) {
        self.len = 0;
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u32) {
        self.len = v;
    }
}

impl ::protobuf::Message for WriteStreamResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.len = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.len != 0 {
            my_size += ::protobuf::rt::value_size(1, self.len, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.len != 0 {
            os.write_uint32(1, self.len)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteStreamResponse {
        WriteStreamResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "len",
                    |m: &WriteStreamResponse| { &m.len },
                    |m: &mut WriteStreamResponse| { &mut m.len },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteStreamResponse>(
                    "WriteStreamResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteStreamResponse {
        static mut instance: ::protobuf::lazy::Lazy<WriteStreamResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WriteStreamResponse::new)
        }
    }
}

impl ::protobuf::Clear for WriteStreamResponse {
    fn clear(&mut self) {
        self.len = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteStreamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteStreamResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadStreamRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub len: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadStreamRequest {
    fn default() -> &'a ReadStreamRequest {
        <ReadStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadStreamRequest {
    pub fn new() -> ReadStreamRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 len = 3;


    pub fn get_len(&self) -> u32 {
        self.len
    }
    pub fn clear_len(&mut self) {
        self.len = 0;
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u32) {
        self.len = v;
    }
}

impl ::protobuf::Message for ReadStreamRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.len = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.len != 0 {
            my_size += ::protobuf::rt::value_size(3, self.len, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.len != 0 {
            os.write_uint32(3, self.len)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadStreamRequest {
        ReadStreamRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ReadStreamRequest| { &m.container_id },
                    |m: &mut ReadStreamRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &ReadStreamRequest| { &m.exec_id },
                    |m: &mut ReadStreamRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "len",
                    |m: &ReadStreamRequest| { &m.len },
                    |m: &mut ReadStreamRequest| { &mut m.len },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadStreamRequest>(
                    "ReadStreamRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadStreamRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReadStreamRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReadStreamRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReadStreamRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.len = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadStreamResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadStreamResponse {
    fn default() -> &'a ReadStreamResponse {
        <ReadStreamResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadStreamResponse {
    pub fn new() -> ReadStreamResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReadStreamResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadStreamResponse {
        ReadStreamResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &ReadStreamResponse| { &m.data },
                    |m: &mut ReadStreamResponse| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadStreamResponse>(
                    "ReadStreamResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadStreamResponse {
        static mut instance: ::protobuf::lazy::Lazy<ReadStreamResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReadStreamResponse::new)
        }
    }
}

impl ::protobuf::Clear for ReadStreamResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadStreamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseStdinRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseStdinRequest {
    fn default() -> &'a CloseStdinRequest {
        <CloseStdinRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseStdinRequest {
    pub fn new() -> CloseStdinRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CloseStdinRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseStdinRequest {
        CloseStdinRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &CloseStdinRequest| { &m.container_id },
                    |m: &mut CloseStdinRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &CloseStdinRequest| { &m.exec_id },
                    |m: &mut CloseStdinRequest| { &mut m.exec_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloseStdinRequest>(
                    "CloseStdinRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseStdinRequest {
        static mut instance: ::protobuf::lazy::Lazy<CloseStdinRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CloseStdinRequest::new)
        }
    }
}

impl ::protobuf::Clear for CloseStdinRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseStdinRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseStdinRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TtyWinResizeRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub row: u32,
    pub column: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TtyWinResizeRequest {
    fn default() -> &'a TtyWinResizeRequest {
        <TtyWinResizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl TtyWinResizeRequest {
    pub fn new() -> TtyWinResizeRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 row = 3;


    pub fn get_row(&self) -> u32 {
        self.row
    }
    pub fn clear_row(&mut self) {
        self.row = 0;
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: u32) {
        self.row = v;
    }

    // uint32 column = 4;


    pub fn get_column(&self) -> u32 {
        self.column
    }
    pub fn clear_column(&mut self) {
        self.column = 0;
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: u32) {
        self.column = v;
    }
}

impl ::protobuf::Message for TtyWinResizeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.row = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.column = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.row != 0 {
            my_size += ::protobuf::rt::value_size(3, self.row, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.column != 0 {
            my_size += ::protobuf::rt::value_size(4, self.column, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.row != 0 {
            os.write_uint32(3, self.row)?;
        }
        if self.column != 0 {
            os.write_uint32(4, self.column)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TtyWinResizeRequest {
        TtyWinResizeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &TtyWinResizeRequest| { &m.container_id },
                    |m: &mut TtyWinResizeRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &TtyWinResizeRequest| { &m.exec_id },
                    |m: &mut TtyWinResizeRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "row",
                    |m: &TtyWinResizeRequest| { &m.row },
                    |m: &mut TtyWinResizeRequest| { &mut m.row },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "column",
                    |m: &TtyWinResizeRequest| { &m.column },
                    |m: &mut TtyWinResizeRequest| { &mut m.column },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TtyWinResizeRequest>(
                    "TtyWinResizeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TtyWinResizeRequest {
        static mut instance: ::protobuf::lazy::Lazy<TtyWinResizeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TtyWinResizeRequest::new)
        }
    }
}

impl ::protobuf::Clear for TtyWinResizeRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.row = 0;
        self.column = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TtyWinResizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TtyWinResizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSandboxRequest {
    // message fields
    pub hostname: ::std::string::String,
    pub dns: ::protobuf::RepeatedField<::std::string::String>,
    pub storages: ::protobuf::RepeatedField<Storage>,
    pub sandbox_pidns: bool,
    pub sandbox_id: ::std::string::String,
    pub guest_hook_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSandboxRequest {
    fn default() -> &'a CreateSandboxRequest {
        <CreateSandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSandboxRequest {
    pub fn new() -> CreateSandboxRequest {
        ::std::default::Default::default()
    }

    // string hostname = 1;


    pub fn get_hostname(&self) -> &str {
        &self.hostname
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        &mut self.hostname
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hostname, ::std::string::String::new())
    }

    // repeated string dns = 2;


    pub fn get_dns(&self) -> &[::std::string::String] {
        &self.dns
    }
    pub fn clear_dns(&mut self) {
        self.dns.clear();
    }

    // Param is passed by value, moved
    pub fn set_dns(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dns(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dns
    }

    // Take field
    pub fn take_dns(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dns, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.Storage storages = 3;


    pub fn get_storages(&self) -> &[Storage] {
        &self.storages
    }
    pub fn clear_storages(&mut self) {
        self.storages.clear();
    }

    // Param is passed by value, moved
    pub fn set_storages(&mut self, v: ::protobuf::RepeatedField<Storage>) {
        self.storages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storages(&mut self) -> &mut ::protobuf::RepeatedField<Storage> {
        &mut self.storages
    }

    // Take field
    pub fn take_storages(&mut self) -> ::protobuf::RepeatedField<Storage> {
        ::std::mem::replace(&mut self.storages, ::protobuf::RepeatedField::new())
    }

    // bool sandbox_pidns = 4;


    pub fn get_sandbox_pidns(&self) -> bool {
        self.sandbox_pidns
    }
    pub fn clear_sandbox_pidns(&mut self) {
        self.sandbox_pidns = false;
    }

    // Param is passed by value, moved
    pub fn set_sandbox_pidns(&mut self, v: bool) {
        self.sandbox_pidns = v;
    }

    // string sandbox_id = 5;


    pub fn get_sandbox_id(&self) -> &str {
        &self.sandbox_id
    }
    pub fn clear_sandbox_id(&mut self) {
        self.sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_sandbox_id(&mut self, v: ::std::string::String) {
        self.sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.sandbox_id
    }

    // Take field
    pub fn take_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sandbox_id, ::std::string::String::new())
    }

    // string guest_hook_path = 6;


    pub fn get_guest_hook_path(&self) -> &str {
        &self.guest_hook_path
    }
    pub fn clear_guest_hook_path(&mut self) {
        self.guest_hook_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_guest_hook_path(&mut self, v: ::std::string::String) {
        self.guest_hook_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guest_hook_path(&mut self) -> &mut ::std::string::String {
        &mut self.guest_hook_path
    }

    // Take field
    pub fn take_guest_hook_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.guest_hook_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateSandboxRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.storages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hostname)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dns)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storages)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sandbox_pidns = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sandbox_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.guest_hook_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hostname);
        }
        for value in &self.dns {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.storages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.sandbox_pidns != false {
            my_size += 2;
        }
        if !self.sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sandbox_id);
        }
        if !self.guest_hook_path.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.guest_hook_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hostname.is_empty() {
            os.write_string(1, &self.hostname)?;
        }
        for v in &self.dns {
            os.write_string(2, &v)?;
        };
        for v in &self.storages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.sandbox_pidns != false {
            os.write_bool(4, self.sandbox_pidns)?;
        }
        if !self.sandbox_id.is_empty() {
            os.write_string(5, &self.sandbox_id)?;
        }
        if !self.guest_hook_path.is_empty() {
            os.write_string(6, &self.guest_hook_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSandboxRequest {
        CreateSandboxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    |m: &CreateSandboxRequest| { &m.hostname },
                    |m: &mut CreateSandboxRequest| { &mut m.hostname },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dns",
                    |m: &CreateSandboxRequest| { &m.dns },
                    |m: &mut CreateSandboxRequest| { &mut m.dns },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Storage>>(
                    "storages",
                    |m: &CreateSandboxRequest| { &m.storages },
                    |m: &mut CreateSandboxRequest| { &mut m.storages },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sandbox_pidns",
                    |m: &CreateSandboxRequest| { &m.sandbox_pidns },
                    |m: &mut CreateSandboxRequest| { &mut m.sandbox_pidns },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sandbox_id",
                    |m: &CreateSandboxRequest| { &m.sandbox_id },
                    |m: &mut CreateSandboxRequest| { &mut m.sandbox_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "guest_hook_path",
                    |m: &CreateSandboxRequest| { &m.guest_hook_path },
                    |m: &mut CreateSandboxRequest| { &mut m.guest_hook_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSandboxRequest>(
                    "CreateSandboxRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSandboxRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateSandboxRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateSandboxRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateSandboxRequest {
    fn clear(&mut self) {
        self.hostname.clear();
        self.dns.clear();
        self.storages.clear();
        self.sandbox_pidns = false;
        self.sandbox_id.clear();
        self.guest_hook_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSandboxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DestroySandboxRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DestroySandboxRequest {
    fn default() -> &'a DestroySandboxRequest {
        <DestroySandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl DestroySandboxRequest {
    pub fn new() -> DestroySandboxRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DestroySandboxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DestroySandboxRequest {
        DestroySandboxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DestroySandboxRequest>(
                    "DestroySandboxRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DestroySandboxRequest {
        static mut instance: ::protobuf::lazy::Lazy<DestroySandboxRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DestroySandboxRequest::new)
        }
    }
}

impl ::protobuf::Clear for DestroySandboxRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DestroySandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DestroySandboxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Interfaces {
    // message fields
    pub Interfaces: ::protobuf::RepeatedField<super::types::Interface>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Interfaces {
    fn default() -> &'a Interfaces {
        <Interfaces as ::protobuf::Message>::default_instance()
    }
}

impl Interfaces {
    pub fn new() -> Interfaces {
        ::std::default::Default::default()
    }

    // repeated .types.Interface Interfaces = 1;


    pub fn get_Interfaces(&self) -> &[super::types::Interface] {
        &self.Interfaces
    }
    pub fn clear_Interfaces(&mut self) {
        self.Interfaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Interfaces(&mut self, v: ::protobuf::RepeatedField<super::types::Interface>) {
        self.Interfaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Interfaces(&mut self) -> &mut ::protobuf::RepeatedField<super::types::Interface> {
        &mut self.Interfaces
    }

    // Take field
    pub fn take_Interfaces(&mut self) -> ::protobuf::RepeatedField<super::types::Interface> {
        ::std::mem::replace(&mut self.Interfaces, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Interfaces {
    fn is_initialized(&self) -> bool {
        for v in &self.Interfaces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Interfaces)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Interfaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Interfaces {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Interfaces {
        Interfaces::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::types::Interface>>(
                    "Interfaces",
                    |m: &Interfaces| { &m.Interfaces },
                    |m: &mut Interfaces| { &mut m.Interfaces },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Interfaces>(
                    "Interfaces",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Interfaces {
        static mut instance: ::protobuf::lazy::Lazy<Interfaces> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Interfaces::new)
        }
    }
}

impl ::protobuf::Clear for Interfaces {
    fn clear(&mut self) {
        self.Interfaces.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Interfaces {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Interfaces {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Routes {
    // message fields
    pub Routes: ::protobuf::RepeatedField<super::types::Route>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Routes {
    fn default() -> &'a Routes {
        <Routes as ::protobuf::Message>::default_instance()
    }
}

impl Routes {
    pub fn new() -> Routes {
        ::std::default::Default::default()
    }

    // repeated .types.Route Routes = 1;


    pub fn get_Routes(&self) -> &[super::types::Route] {
        &self.Routes
    }
    pub fn clear_Routes(&mut self) {
        self.Routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_Routes(&mut self, v: ::protobuf::RepeatedField<super::types::Route>) {
        self.Routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Routes(&mut self) -> &mut ::protobuf::RepeatedField<super::types::Route> {
        &mut self.Routes
    }

    // Take field
    pub fn take_Routes(&mut self) -> ::protobuf::RepeatedField<super::types::Route> {
        ::std::mem::replace(&mut self.Routes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Routes {
    fn is_initialized(&self) -> bool {
        for v in &self.Routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Routes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Routes {
        Routes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::types::Route>>(
                    "Routes",
                    |m: &Routes| { &m.Routes },
                    |m: &mut Routes| { &mut m.Routes },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Routes>(
                    "Routes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Routes {
        static mut instance: ::protobuf::lazy::Lazy<Routes> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Routes::new)
        }
    }
}

impl ::protobuf::Clear for Routes {
    fn clear(&mut self) {
        self.Routes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Routes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Routes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateInterfaceRequest {
    // message fields
    pub interface: ::protobuf::SingularPtrField<super::types::Interface>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateInterfaceRequest {
    fn default() -> &'a UpdateInterfaceRequest {
        <UpdateInterfaceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateInterfaceRequest {
    pub fn new() -> UpdateInterfaceRequest {
        ::std::default::Default::default()
    }

    // .types.Interface interface = 1;


    pub fn get_interface(&self) -> &super::types::Interface {
        self.interface.as_ref().unwrap_or_else(|| super::types::Interface::default_instance())
    }
    pub fn clear_interface(&mut self) {
        self.interface.clear();
    }

    pub fn has_interface(&self) -> bool {
        self.interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface(&mut self, v: super::types::Interface) {
        self.interface = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface(&mut self) -> &mut super::types::Interface {
        if self.interface.is_none() {
            self.interface.set_default();
        }
        self.interface.as_mut().unwrap()
    }

    // Take field
    pub fn take_interface(&mut self) -> super::types::Interface {
        self.interface.take().unwrap_or_else(|| super::types::Interface::new())
    }
}

impl ::protobuf::Message for UpdateInterfaceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.interface {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interface)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.interface.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.interface.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateInterfaceRequest {
        UpdateInterfaceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::types::Interface>>(
                    "interface",
                    |m: &UpdateInterfaceRequest| { &m.interface },
                    |m: &mut UpdateInterfaceRequest| { &mut m.interface },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateInterfaceRequest>(
                    "UpdateInterfaceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateInterfaceRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateInterfaceRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateInterfaceRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateInterfaceRequest {
    fn clear(&mut self) {
        self.interface.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateInterfaceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateInterfaceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRoutesRequest {
    // message fields
    pub routes: ::protobuf::SingularPtrField<Routes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRoutesRequest {
    fn default() -> &'a UpdateRoutesRequest {
        <UpdateRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRoutesRequest {
    pub fn new() -> UpdateRoutesRequest {
        ::std::default::Default::default()
    }

    // .grpc.Routes routes = 1;


    pub fn get_routes(&self) -> &Routes {
        self.routes.as_ref().unwrap_or_else(|| Routes::default_instance())
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: Routes) {
        self.routes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut Routes {
        if self.routes.is_none() {
            self.routes.set_default();
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> Routes {
        self.routes.take().unwrap_or_else(|| Routes::new())
    }
}

impl ::protobuf::Message for UpdateRoutesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.routes.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRoutesRequest {
        UpdateRoutesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Routes>>(
                    "routes",
                    |m: &UpdateRoutesRequest| { &m.routes },
                    |m: &mut UpdateRoutesRequest| { &mut m.routes },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRoutesRequest>(
                    "UpdateRoutesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateRoutesRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateRoutesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateRoutesRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateRoutesRequest {
    fn clear(&mut self) {
        self.routes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRoutesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInterfacesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInterfacesRequest {
    fn default() -> &'a ListInterfacesRequest {
        <ListInterfacesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInterfacesRequest {
    pub fn new() -> ListInterfacesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListInterfacesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInterfacesRequest {
        ListInterfacesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListInterfacesRequest>(
                    "ListInterfacesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInterfacesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListInterfacesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListInterfacesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListInterfacesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInterfacesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInterfacesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRoutesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRoutesRequest {
    fn default() -> &'a ListRoutesRequest {
        <ListRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRoutesRequest {
    pub fn new() -> ListRoutesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListRoutesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRoutesRequest {
        ListRoutesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListRoutesRequest>(
                    "ListRoutesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListRoutesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListRoutesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListRoutesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListRoutesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRoutesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnlineCPUMemRequest {
    // message fields
    pub wait: bool,
    pub nb_cpus: u32,
    pub cpu_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnlineCPUMemRequest {
    fn default() -> &'a OnlineCPUMemRequest {
        <OnlineCPUMemRequest as ::protobuf::Message>::default_instance()
    }
}

impl OnlineCPUMemRequest {
    pub fn new() -> OnlineCPUMemRequest {
        ::std::default::Default::default()
    }

    // bool wait = 1;


    pub fn get_wait(&self) -> bool {
        self.wait
    }
    pub fn clear_wait(&mut self) {
        self.wait = false;
    }

    // Param is passed by value, moved
    pub fn set_wait(&mut self, v: bool) {
        self.wait = v;
    }

    // uint32 nb_cpus = 2;


    pub fn get_nb_cpus(&self) -> u32 {
        self.nb_cpus
    }
    pub fn clear_nb_cpus(&mut self) {
        self.nb_cpus = 0;
    }

    // Param is passed by value, moved
    pub fn set_nb_cpus(&mut self, v: u32) {
        self.nb_cpus = v;
    }

    // bool cpu_only = 3;


    pub fn get_cpu_only(&self) -> bool {
        self.cpu_only
    }
    pub fn clear_cpu_only(&mut self) {
        self.cpu_only = false;
    }

    // Param is passed by value, moved
    pub fn set_cpu_only(&mut self, v: bool) {
        self.cpu_only = v;
    }
}

impl ::protobuf::Message for OnlineCPUMemRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wait = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nb_cpus = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cpu_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wait != false {
            my_size += 2;
        }
        if self.nb_cpus != 0 {
            my_size += ::protobuf::rt::value_size(2, self.nb_cpus, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpu_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.wait != false {
            os.write_bool(1, self.wait)?;
        }
        if self.nb_cpus != 0 {
            os.write_uint32(2, self.nb_cpus)?;
        }
        if self.cpu_only != false {
            os.write_bool(3, self.cpu_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnlineCPUMemRequest {
        OnlineCPUMemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "wait",
                    |m: &OnlineCPUMemRequest| { &m.wait },
                    |m: &mut OnlineCPUMemRequest| { &mut m.wait },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "nb_cpus",
                    |m: &OnlineCPUMemRequest| { &m.nb_cpus },
                    |m: &mut OnlineCPUMemRequest| { &mut m.nb_cpus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "cpu_only",
                    |m: &OnlineCPUMemRequest| { &m.cpu_only },
                    |m: &mut OnlineCPUMemRequest| { &mut m.cpu_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<OnlineCPUMemRequest>(
                    "OnlineCPUMemRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OnlineCPUMemRequest {
        static mut instance: ::protobuf::lazy::Lazy<OnlineCPUMemRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(OnlineCPUMemRequest::new)
        }
    }
}

impl ::protobuf::Clear for OnlineCPUMemRequest {
    fn clear(&mut self) {
        self.wait = false;
        self.nb_cpus = 0;
        self.cpu_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnlineCPUMemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnlineCPUMemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReseedRandomDevRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReseedRandomDevRequest {
    fn default() -> &'a ReseedRandomDevRequest {
        <ReseedRandomDevRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReseedRandomDevRequest {
    pub fn new() -> ReseedRandomDevRequest {
        ::std::default::Default::default()
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReseedRandomDevRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReseedRandomDevRequest {
        ReseedRandomDevRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &ReseedRandomDevRequest| { &m.data },
                    |m: &mut ReseedRandomDevRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReseedRandomDevRequest>(
                    "ReseedRandomDevRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReseedRandomDevRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReseedRandomDevRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReseedRandomDevRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReseedRandomDevRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReseedRandomDevRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReseedRandomDevRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentDetails {
    // message fields
    pub version: ::std::string::String,
    pub init_daemon: bool,
    pub device_handlers: ::protobuf::RepeatedField<::std::string::String>,
    pub storage_handlers: ::protobuf::RepeatedField<::std::string::String>,
    pub supports_seccomp: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AgentDetails {
    fn default() -> &'a AgentDetails {
        <AgentDetails as ::protobuf::Message>::default_instance()
    }
}

impl AgentDetails {
    pub fn new() -> AgentDetails {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // bool init_daemon = 2;


    pub fn get_init_daemon(&self) -> bool {
        self.init_daemon
    }
    pub fn clear_init_daemon(&mut self) {
        self.init_daemon = false;
    }

    // Param is passed by value, moved
    pub fn set_init_daemon(&mut self, v: bool) {
        self.init_daemon = v;
    }

    // repeated string device_handlers = 3;


    pub fn get_device_handlers(&self) -> &[::std::string::String] {
        &self.device_handlers
    }
    pub fn clear_device_handlers(&mut self) {
        self.device_handlers.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_handlers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.device_handlers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_handlers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.device_handlers
    }

    // Take field
    pub fn take_device_handlers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.device_handlers, ::protobuf::RepeatedField::new())
    }

    // repeated string storage_handlers = 4;


    pub fn get_storage_handlers(&self) -> &[::std::string::String] {
        &self.storage_handlers
    }
    pub fn clear_storage_handlers(&mut self) {
        self.storage_handlers.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_handlers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storage_handlers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storage_handlers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storage_handlers
    }

    // Take field
    pub fn take_storage_handlers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storage_handlers, ::protobuf::RepeatedField::new())
    }

    // bool supports_seccomp = 5;


    pub fn get_supports_seccomp(&self) -> bool {
        self.supports_seccomp
    }
    pub fn clear_supports_seccomp(&mut self) {
        self.supports_seccomp = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_seccomp(&mut self, v: bool) {
        self.supports_seccomp = v;
    }
}

impl ::protobuf::Message for AgentDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.init_daemon = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.device_handlers)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storage_handlers)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_seccomp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if self.init_daemon != false {
            my_size += 2;
        }
        for value in &self.device_handlers {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.storage_handlers {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.supports_seccomp != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if self.init_daemon != false {
            os.write_bool(2, self.init_daemon)?;
        }
        for v in &self.device_handlers {
            os.write_string(3, &v)?;
        };
        for v in &self.storage_handlers {
            os.write_string(4, &v)?;
        };
        if self.supports_seccomp != false {
            os.write_bool(5, self.supports_seccomp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgentDetails {
        AgentDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &AgentDetails| { &m.version },
                    |m: &mut AgentDetails| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "init_daemon",
                    |m: &AgentDetails| { &m.init_daemon },
                    |m: &mut AgentDetails| { &mut m.init_daemon },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_handlers",
                    |m: &AgentDetails| { &m.device_handlers },
                    |m: &mut AgentDetails| { &mut m.device_handlers },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storage_handlers",
                    |m: &AgentDetails| { &m.storage_handlers },
                    |m: &mut AgentDetails| { &mut m.storage_handlers },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_seccomp",
                    |m: &AgentDetails| { &m.supports_seccomp },
                    |m: &mut AgentDetails| { &mut m.supports_seccomp },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AgentDetails>(
                    "AgentDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AgentDetails {
        static mut instance: ::protobuf::lazy::Lazy<AgentDetails> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AgentDetails::new)
        }
    }
}

impl ::protobuf::Clear for AgentDetails {
    fn clear(&mut self) {
        self.version.clear();
        self.init_daemon = false;
        self.device_handlers.clear();
        self.storage_handlers.clear();
        self.supports_seccomp = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuestDetailsRequest {
    // message fields
    pub mem_block_size: bool,
    pub mem_hotplug_probe: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuestDetailsRequest {
    fn default() -> &'a GuestDetailsRequest {
        <GuestDetailsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GuestDetailsRequest {
    pub fn new() -> GuestDetailsRequest {
        ::std::default::Default::default()
    }

    // bool mem_block_size = 1;


    pub fn get_mem_block_size(&self) -> bool {
        self.mem_block_size
    }
    pub fn clear_mem_block_size(&mut self) {
        self.mem_block_size = false;
    }

    // Param is passed by value, moved
    pub fn set_mem_block_size(&mut self, v: bool) {
        self.mem_block_size = v;
    }

    // bool mem_hotplug_probe = 2;


    pub fn get_mem_hotplug_probe(&self) -> bool {
        self.mem_hotplug_probe
    }
    pub fn clear_mem_hotplug_probe(&mut self) {
        self.mem_hotplug_probe = false;
    }

    // Param is passed by value, moved
    pub fn set_mem_hotplug_probe(&mut self, v: bool) {
        self.mem_hotplug_probe = v;
    }
}

impl ::protobuf::Message for GuestDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mem_block_size = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mem_hotplug_probe = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mem_block_size != false {
            my_size += 2;
        }
        if self.mem_hotplug_probe != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mem_block_size != false {
            os.write_bool(1, self.mem_block_size)?;
        }
        if self.mem_hotplug_probe != false {
            os.write_bool(2, self.mem_hotplug_probe)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuestDetailsRequest {
        GuestDetailsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mem_block_size",
                    |m: &GuestDetailsRequest| { &m.mem_block_size },
                    |m: &mut GuestDetailsRequest| { &mut m.mem_block_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mem_hotplug_probe",
                    |m: &GuestDetailsRequest| { &m.mem_hotplug_probe },
                    |m: &mut GuestDetailsRequest| { &mut m.mem_hotplug_probe },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GuestDetailsRequest>(
                    "GuestDetailsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GuestDetailsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GuestDetailsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GuestDetailsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GuestDetailsRequest {
    fn clear(&mut self) {
        self.mem_block_size = false;
        self.mem_hotplug_probe = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuestDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuestDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuestDetailsResponse {
    // message fields
    pub mem_block_size_bytes: u64,
    pub agent_details: ::protobuf::SingularPtrField<AgentDetails>,
    pub support_mem_hotplug_probe: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuestDetailsResponse {
    fn default() -> &'a GuestDetailsResponse {
        <GuestDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GuestDetailsResponse {
    pub fn new() -> GuestDetailsResponse {
        ::std::default::Default::default()
    }

    // uint64 mem_block_size_bytes = 1;


    pub fn get_mem_block_size_bytes(&self) -> u64 {
        self.mem_block_size_bytes
    }
    pub fn clear_mem_block_size_bytes(&mut self) {
        self.mem_block_size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_mem_block_size_bytes(&mut self, v: u64) {
        self.mem_block_size_bytes = v;
    }

    // .grpc.AgentDetails agent_details = 2;


    pub fn get_agent_details(&self) -> &AgentDetails {
        self.agent_details.as_ref().unwrap_or_else(|| AgentDetails::default_instance())
    }
    pub fn clear_agent_details(&mut self) {
        self.agent_details.clear();
    }

    pub fn has_agent_details(&self) -> bool {
        self.agent_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_details(&mut self, v: AgentDetails) {
        self.agent_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_details(&mut self) -> &mut AgentDetails {
        if self.agent_details.is_none() {
            self.agent_details.set_default();
        }
        self.agent_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_details(&mut self) -> AgentDetails {
        self.agent_details.take().unwrap_or_else(|| AgentDetails::new())
    }

    // bool support_mem_hotplug_probe = 3;


    pub fn get_support_mem_hotplug_probe(&self) -> bool {
        self.support_mem_hotplug_probe
    }
    pub fn clear_support_mem_hotplug_probe(&mut self) {
        self.support_mem_hotplug_probe = false;
    }

    // Param is passed by value, moved
    pub fn set_support_mem_hotplug_probe(&mut self, v: bool) {
        self.support_mem_hotplug_probe = v;
    }
}

impl ::protobuf::Message for GuestDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.agent_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_block_size_bytes = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_details)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.support_mem_hotplug_probe = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mem_block_size_bytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mem_block_size_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.agent_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.support_mem_hotplug_probe != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mem_block_size_bytes != 0 {
            os.write_uint64(1, self.mem_block_size_bytes)?;
        }
        if let Some(ref v) = self.agent_details.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.support_mem_hotplug_probe != false {
            os.write_bool(3, self.support_mem_hotplug_probe)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuestDetailsResponse {
        GuestDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_block_size_bytes",
                    |m: &GuestDetailsResponse| { &m.mem_block_size_bytes },
                    |m: &mut GuestDetailsResponse| { &mut m.mem_block_size_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentDetails>>(
                    "agent_details",
                    |m: &GuestDetailsResponse| { &m.agent_details },
                    |m: &mut GuestDetailsResponse| { &mut m.agent_details },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "support_mem_hotplug_probe",
                    |m: &GuestDetailsResponse| { &m.support_mem_hotplug_probe },
                    |m: &mut GuestDetailsResponse| { &mut m.support_mem_hotplug_probe },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GuestDetailsResponse>(
                    "GuestDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GuestDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GuestDetailsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GuestDetailsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GuestDetailsResponse {
    fn clear(&mut self) {
        self.mem_block_size_bytes = 0;
        self.agent_details.clear();
        self.support_mem_hotplug_probe = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuestDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuestDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemHotplugByProbeRequest {
    // message fields
    pub memHotplugProbeAddr: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemHotplugByProbeRequest {
    fn default() -> &'a MemHotplugByProbeRequest {
        <MemHotplugByProbeRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemHotplugByProbeRequest {
    pub fn new() -> MemHotplugByProbeRequest {
        ::std::default::Default::default()
    }

    // repeated uint64 memHotplugProbeAddr = 1;


    pub fn get_memHotplugProbeAddr(&self) -> &[u64] {
        &self.memHotplugProbeAddr
    }
    pub fn clear_memHotplugProbeAddr(&mut self) {
        self.memHotplugProbeAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_memHotplugProbeAddr(&mut self, v: ::std::vec::Vec<u64>) {
        self.memHotplugProbeAddr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memHotplugProbeAddr(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.memHotplugProbeAddr
    }

    // Take field
    pub fn take_memHotplugProbeAddr(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.memHotplugProbeAddr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MemHotplugByProbeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.memHotplugProbeAddr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.memHotplugProbeAddr {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.memHotplugProbeAddr {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemHotplugByProbeRequest {
        MemHotplugByProbeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "memHotplugProbeAddr",
                    |m: &MemHotplugByProbeRequest| { &m.memHotplugProbeAddr },
                    |m: &mut MemHotplugByProbeRequest| { &mut m.memHotplugProbeAddr },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemHotplugByProbeRequest>(
                    "MemHotplugByProbeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemHotplugByProbeRequest {
        static mut instance: ::protobuf::lazy::Lazy<MemHotplugByProbeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MemHotplugByProbeRequest::new)
        }
    }
}

impl ::protobuf::Clear for MemHotplugByProbeRequest {
    fn clear(&mut self) {
        self.memHotplugProbeAddr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemHotplugByProbeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemHotplugByProbeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetGuestDateTimeRequest {
    // message fields
    pub Sec: i64,
    pub Usec: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetGuestDateTimeRequest {
    fn default() -> &'a SetGuestDateTimeRequest {
        <SetGuestDateTimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetGuestDateTimeRequest {
    pub fn new() -> SetGuestDateTimeRequest {
        ::std::default::Default::default()
    }

    // int64 Sec = 1;


    pub fn get_Sec(&self) -> i64 {
        self.Sec
    }
    pub fn clear_Sec(&mut self) {
        self.Sec = 0;
    }

    // Param is passed by value, moved
    pub fn set_Sec(&mut self, v: i64) {
        self.Sec = v;
    }

    // int64 Usec = 2;


    pub fn get_Usec(&self) -> i64 {
        self.Usec
    }
    pub fn clear_Usec(&mut self) {
        self.Usec = 0;
    }

    // Param is passed by value, moved
    pub fn set_Usec(&mut self, v: i64) {
        self.Usec = v;
    }
}

impl ::protobuf::Message for SetGuestDateTimeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Sec = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Usec = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Sec != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Sec, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Usec != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Usec, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Sec != 0 {
            os.write_int64(1, self.Sec)?;
        }
        if self.Usec != 0 {
            os.write_int64(2, self.Usec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetGuestDateTimeRequest {
        SetGuestDateTimeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Sec",
                    |m: &SetGuestDateTimeRequest| { &m.Sec },
                    |m: &mut SetGuestDateTimeRequest| { &mut m.Sec },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Usec",
                    |m: &SetGuestDateTimeRequest| { &m.Usec },
                    |m: &mut SetGuestDateTimeRequest| { &mut m.Usec },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetGuestDateTimeRequest>(
                    "SetGuestDateTimeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetGuestDateTimeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetGuestDateTimeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SetGuestDateTimeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetGuestDateTimeRequest {
    fn clear(&mut self) {
        self.Sec = 0;
        self.Usec = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetGuestDateTimeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetGuestDateTimeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Storage {
    // message fields
    pub driver: ::std::string::String,
    pub driver_options: ::protobuf::RepeatedField<::std::string::String>,
    pub source: ::std::string::String,
    pub fstype: ::std::string::String,
    pub options: ::protobuf::RepeatedField<::std::string::String>,
    pub mount_point: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Storage {
    fn default() -> &'a Storage {
        <Storage as ::protobuf::Message>::default_instance()
    }
}

impl Storage {
    pub fn new() -> Storage {
        ::std::default::Default::default()
    }

    // string driver = 1;


    pub fn get_driver(&self) -> &str {
        &self.driver
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        &mut self.driver
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.driver, ::std::string::String::new())
    }

    // repeated string driver_options = 2;


    pub fn get_driver_options(&self) -> &[::std::string::String] {
        &self.driver_options
    }
    pub fn clear_driver_options(&mut self) {
        self.driver_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.driver_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_driver_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.driver_options
    }

    // Take field
    pub fn take_driver_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.driver_options, ::protobuf::RepeatedField::new())
    }

    // string source = 3;


    pub fn get_source(&self) -> &str {
        &self.source
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    // string fstype = 4;


    pub fn get_fstype(&self) -> &str {
        &self.fstype
    }
    pub fn clear_fstype(&mut self) {
        self.fstype.clear();
    }

    // Param is passed by value, moved
    pub fn set_fstype(&mut self, v: ::std::string::String) {
        self.fstype = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fstype(&mut self) -> &mut ::std::string::String {
        &mut self.fstype
    }

    // Take field
    pub fn take_fstype(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fstype, ::std::string::String::new())
    }

    // repeated string options = 5;


    pub fn get_options(&self) -> &[::std::string::String] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }

    // string mount_point = 6;


    pub fn get_mount_point(&self) -> &str {
        &self.mount_point
    }
    pub fn clear_mount_point(&mut self) {
        self.mount_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_mount_point(&mut self, v: ::std::string::String) {
        self.mount_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mount_point(&mut self) -> &mut ::std::string::String {
        &mut self.mount_point
    }

    // Take field
    pub fn take_mount_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mount_point, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Storage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.driver)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.driver_options)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fstype)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mount_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.driver.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.driver);
        }
        for value in &self.driver_options {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        if !self.fstype.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.fstype);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.mount_point.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.mount_point);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.driver.is_empty() {
            os.write_string(1, &self.driver)?;
        }
        for v in &self.driver_options {
            os.write_string(2, &v)?;
        };
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        if !self.fstype.is_empty() {
            os.write_string(4, &self.fstype)?;
        }
        for v in &self.options {
            os.write_string(5, &v)?;
        };
        if !self.mount_point.is_empty() {
            os.write_string(6, &self.mount_point)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Storage {
        Storage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "driver",
                    |m: &Storage| { &m.driver },
                    |m: &mut Storage| { &mut m.driver },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "driver_options",
                    |m: &Storage| { &m.driver_options },
                    |m: &mut Storage| { &mut m.driver_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    |m: &Storage| { &m.source },
                    |m: &mut Storage| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fstype",
                    |m: &Storage| { &m.fstype },
                    |m: &mut Storage| { &mut m.fstype },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "options",
                    |m: &Storage| { &m.options },
                    |m: &mut Storage| { &mut m.options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mount_point",
                    |m: &Storage| { &m.mount_point },
                    |m: &mut Storage| { &mut m.mount_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Storage>(
                    "Storage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Storage {
        static mut instance: ::protobuf::lazy::Lazy<Storage> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Storage::new)
        }
    }
}

impl ::protobuf::Clear for Storage {
    fn clear(&mut self) {
        self.driver.clear();
        self.driver_options.clear();
        self.source.clear();
        self.fstype.clear();
        self.options.clear();
        self.mount_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Storage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Storage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    pub vm_path: ::std::string::String,
    pub container_path: ::std::string::String,
    pub options: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string vm_path = 3;


    pub fn get_vm_path(&self) -> &str {
        &self.vm_path
    }
    pub fn clear_vm_path(&mut self) {
        self.vm_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_vm_path(&mut self, v: ::std::string::String) {
        self.vm_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vm_path(&mut self) -> &mut ::std::string::String {
        &mut self.vm_path
    }

    // Take field
    pub fn take_vm_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vm_path, ::std::string::String::new())
    }

    // string container_path = 4;


    pub fn get_container_path(&self) -> &str {
        &self.container_path
    }
    pub fn clear_container_path(&mut self) {
        self.container_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_path(&mut self, v: ::std::string::String) {
        self.container_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_path(&mut self) -> &mut ::std::string::String {
        &mut self.container_path
    }

    // Take field
    pub fn take_container_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_path, ::std::string::String::new())
    }

    // repeated string options = 5;


    pub fn get_options(&self) -> &[::std::string::String] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vm_path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_path)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if !self.vm_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.vm_path);
        }
        if !self.container_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.container_path);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if !self.vm_path.is_empty() {
            os.write_string(3, &self.vm_path)?;
        }
        if !self.container_path.is_empty() {
            os.write_string(4, &self.container_path)?;
        }
        for v in &self.options {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Device| { &m.id },
                    |m: &mut Device| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Device| { &m.field_type },
                    |m: &mut Device| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vm_path",
                    |m: &Device| { &m.vm_path },
                    |m: &mut Device| { &mut m.vm_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_path",
                    |m: &Device| { &m.container_path },
                    |m: &mut Device| { &mut m.container_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "options",
                    |m: &Device| { &m.options },
                    |m: &mut Device| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Device>(
                    "Device",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Device {
        static mut instance: ::protobuf::lazy::Lazy<Device> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Device::new)
        }
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type.clear();
        self.vm_path.clear();
        self.container_path.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringUser {
    // message fields
    pub uid: ::std::string::String,
    pub gid: ::std::string::String,
    pub additionalGids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringUser {
    fn default() -> &'a StringUser {
        <StringUser as ::protobuf::Message>::default_instance()
    }
}

impl StringUser {
    pub fn new() -> StringUser {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string gid = 2;


    pub fn get_gid(&self) -> &str {
        &self.gid
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::string::String) {
        self.gid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::string::String {
        &mut self.gid
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gid, ::std::string::String::new())
    }

    // repeated string additionalGids = 3;


    pub fn get_additionalGids(&self) -> &[::std::string::String] {
        &self.additionalGids
    }
    pub fn clear_additionalGids(&mut self) {
        self.additionalGids.clear();
    }

    // Param is passed by value, moved
    pub fn set_additionalGids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.additionalGids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additionalGids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.additionalGids
    }

    // Take field
    pub fn take_additionalGids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.additionalGids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StringUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gid)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.additionalGids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.gid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.gid);
        }
        for value in &self.additionalGids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.gid.is_empty() {
            os.write_string(2, &self.gid)?;
        }
        for v in &self.additionalGids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringUser {
        StringUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &StringUser| { &m.uid },
                    |m: &mut StringUser| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gid",
                    |m: &StringUser| { &m.gid },
                    |m: &mut StringUser| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "additionalGids",
                    |m: &StringUser| { &m.additionalGids },
                    |m: &mut StringUser| { &mut m.additionalGids },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringUser>(
                    "StringUser",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StringUser {
        static mut instance: ::protobuf::lazy::Lazy<StringUser> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StringUser::new)
        }
    }
}

impl ::protobuf::Clear for StringUser {
    fn clear(&mut self) {
        self.uid.clear();
        self.gid.clear();
        self.additionalGids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringUser {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyFileRequest {
    // message fields
    pub path: ::std::string::String,
    pub file_size: i64,
    pub file_mode: u32,
    pub dir_mode: u32,
    pub uid: i32,
    pub gid: i32,
    pub offset: i64,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyFileRequest {
    fn default() -> &'a CopyFileRequest {
        <CopyFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CopyFileRequest {
    pub fn new() -> CopyFileRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // int64 file_size = 2;


    pub fn get_file_size(&self) -> i64 {
        self.file_size
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: i64) {
        self.file_size = v;
    }

    // uint32 file_mode = 3;


    pub fn get_file_mode(&self) -> u32 {
        self.file_mode
    }
    pub fn clear_file_mode(&mut self) {
        self.file_mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_mode(&mut self, v: u32) {
        self.file_mode = v;
    }

    // uint32 dir_mode = 4;


    pub fn get_dir_mode(&self) -> u32 {
        self.dir_mode
    }
    pub fn clear_dir_mode(&mut self) {
        self.dir_mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_dir_mode(&mut self, v: u32) {
        self.dir_mode = v;
    }

    // int32 uid = 5;


    pub fn get_uid(&self) -> i32 {
        self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid = 0;
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: i32) {
        self.uid = v;
    }

    // int32 gid = 6;


    pub fn get_gid(&self) -> i32 {
        self.gid
    }
    pub fn clear_gid(&mut self) {
        self.gid = 0;
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: i32) {
        self.gid = v;
    }

    // int64 offset = 7;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // bytes data = 8;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CopyFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.file_size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_mode = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dir_mode = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.uid = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gid = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.file_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.file_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.file_mode != 0 {
            my_size += ::protobuf::rt::value_size(3, self.file_mode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dir_mode != 0 {
            my_size += ::protobuf::rt::value_size(4, self.dir_mode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::value_size(5, self.uid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.gid != 0 {
            my_size += ::protobuf::rt::value_size(6, self.gid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(7, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.file_size != 0 {
            os.write_int64(2, self.file_size)?;
        }
        if self.file_mode != 0 {
            os.write_uint32(3, self.file_mode)?;
        }
        if self.dir_mode != 0 {
            os.write_uint32(4, self.dir_mode)?;
        }
        if self.uid != 0 {
            os.write_int32(5, self.uid)?;
        }
        if self.gid != 0 {
            os.write_int32(6, self.gid)?;
        }
        if self.offset != 0 {
            os.write_int64(7, self.offset)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(8, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyFileRequest {
        CopyFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CopyFileRequest| { &m.path },
                    |m: &mut CopyFileRequest| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "file_size",
                    |m: &CopyFileRequest| { &m.file_size },
                    |m: &mut CopyFileRequest| { &mut m.file_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "file_mode",
                    |m: &CopyFileRequest| { &m.file_mode },
                    |m: &mut CopyFileRequest| { &mut m.file_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dir_mode",
                    |m: &CopyFileRequest| { &m.dir_mode },
                    |m: &mut CopyFileRequest| { &mut m.dir_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "uid",
                    |m: &CopyFileRequest| { &m.uid },
                    |m: &mut CopyFileRequest| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "gid",
                    |m: &CopyFileRequest| { &m.gid },
                    |m: &mut CopyFileRequest| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &CopyFileRequest| { &m.offset },
                    |m: &mut CopyFileRequest| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &CopyFileRequest| { &m.data },
                    |m: &mut CopyFileRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyFileRequest>(
                    "CopyFileRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CopyFileRequest {
        static mut instance: ::protobuf::lazy::Lazy<CopyFileRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CopyFileRequest::new)
        }
    }
}

impl ::protobuf::Clear for CopyFileRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.file_size = 0;
        self.file_mode = 0;
        self.dir_mode = 0;
        self.uid = 0;
        self.gid = 0;
        self.offset = 0;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartTracingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartTracingRequest {
    fn default() -> &'a StartTracingRequest {
        <StartTracingRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartTracingRequest {
    pub fn new() -> StartTracingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartTracingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartTracingRequest {
        StartTracingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartTracingRequest>(
                    "StartTracingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartTracingRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartTracingRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StartTracingRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartTracingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartTracingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartTracingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopTracingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopTracingRequest {
    fn default() -> &'a StopTracingRequest {
        <StopTracingRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopTracingRequest {
    pub fn new() -> StopTracingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopTracingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopTracingRequest {
        StopTracingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopTracingRequest>(
                    "StopTracingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopTracingRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopTracingRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StopTracingRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopTracingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopTracingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopTracingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bagent.proto\x12\x04grpc\"\xe6\x01\n\x16CreateContainerRequest\x12\
    \x16\n\x0ccontainer_id\x18\x01\x20\x01(\tB\0\x12\x11\n\x07exec_id\x18\
    \x02\x20\x01(\tB\0\x12'\n\x0bstring_user\x18\x03\x20\x01(\x0b2\x10.grpc.\
    StringUserB\0\x12\x1f\n\x07devices\x18\x04\x20\x03(\x0b2\x0c.grpc.Device\
    B\0\x12!\n\x08storages\x18\x05\x20\x03(\x0b2\r.grpc.StorageB\0\x12\x19\n\
    \x03OCI\x18\x06\x20\x01(\x0b2\n.grpc.SpecB\0\x12\x17\n\rsandbox_pidns\
    \x18\x07\x20\x01(\x08B\0:\0\"1\n\x15StartContainerRequest\x12\x16\n\x0cc\
    ontainer_id\x18\x01\x20\x01(\tB\0:\0\"E\n\x16RemoveContainerRequest\x12\
    \x16\n\x0ccontainer_id\x18\x01\x20\x01(\tB\0\x12\x11\n\x07timeout\x18\
    \x02\x20\x01(\rB\0:\0\"\x8c\x01\n\x12ExecProcessRequest\x12\x16\n\x0ccon\
    tainer_id\x18\x01\x20\x01(\tB\0\x12\x11\n\x07exec_id\x18\x02\x20\x01(\tB\
    \0\x12'\n\x0bstring_user\x18\x03\x20\x01(\x0b2\x10.grpc.StringUserB\0\
    \x12\x20\n\x07process\x18\x04\x20\x01(\x0b2\r.grpc.ProcessB\0:\0\"U\n\
    \x14SignalProcessRequest\x12\x16\n\x0ccontainer_id\x18\x01\x20\x01(\tB\0\
    \x12\x11\n\x07exec_id\x18\x02\x20\x01(\tB\0\x12\x10\n\x06signal\x18\x03\
    \x20\x01(\rB\0:\0\"A\n\x12WaitProcessRequest\x12\x16\n\x0ccontainer_id\
    \x18\x01\x20\x01(\tB\0\x12\x11\n\x07exec_id\x18\x02\x20\x01(\tB\0:\0\")\
    \n\x13WaitProcessResponse\x12\x10\n\x06status\x18\x01\x20\x01(\x05B\0:\0\
    \"R\n\x14ListProcessesRequest\x12\x16\n\x0ccontainer_id\x18\x01\x20\x01(\
    \tB\0\x12\x10\n\x06format\x18\x02\x20\x01(\tB\0\x12\x0e\n\x04args\x18\
    \x03\x20\x03(\tB\0:\0\"1\n\x15ListProcessesResponse\x12\x16\n\x0cprocess\
    _list\x18\x01\x20\x01(\x0cB\0:\0\"]\n\x16UpdateContainerRequest\x12\x16\
    \n\x0ccontainer_id\x18\x01\x20\x01(\tB\0\x12)\n\tresources\x18\x02\x20\
    \x01(\x0b2\x14.grpc.LinuxResourcesB\0:\0\"1\n\x15StatsContainerRequest\
    \x12\x16\n\x0ccontainer_id\x18\x01\x20\x01(\tB\0:\0\"1\n\x15PauseContain\
    erRequest\x12\x16\n\x0ccontainer_id\x18\x01\x20\x01(\tB\0:\0\"2\n\x16Res\
    umeContainerRequest\x12\x16\n\x0ccontainer_id\x18\x01\x20\x01(\tB\0:\0\"\
    w\n\x08CpuUsage\x12\x15\n\x0btotal_usage\x18\x01\x20\x01(\x04B\0\x12\x16\
    \n\x0cpercpu_usage\x18\x02\x20\x03(\x04B\0\x12\x1d\n\x13usage_in_kernelm\
    ode\x18\x03\x20\x01(\x04B\0\x12\x1b\n\x11usage_in_usermode\x18\x04\x20\
    \x01(\x04B\0:\0\"\\\n\x0eThrottlingData\x12\x11\n\x07periods\x18\x01\x20\
    \x01(\x04B\0\x12\x1b\n\x11throttled_periods\x18\x02\x20\x01(\x04B\0\x12\
    \x18\n\x0ethrottled_time\x18\x03\x20\x01(\x04B\0:\0\"b\n\x08CpuStats\x12\
    #\n\tcpu_usage\x18\x01\x20\x01(\x0b2\x0e.grpc.CpuUsageB\0\x12/\n\x0fthro\
    ttling_data\x18\x02\x20\x01(\x0b2\x14.grpc.ThrottlingDataB\0:\0\"1\n\tPi\
    dsStats\x12\x11\n\x07current\x18\x01\x20\x01(\x04B\0\x12\x0f\n\x05limit\
    \x18\x02\x20\x01(\x04B\0:\0\"X\n\nMemoryData\x12\x0f\n\x05usage\x18\x01\
    \x20\x01(\x04B\0\x12\x13\n\tmax_usage\x18\x02\x20\x01(\x04B\0\x12\x11\n\
    \x07failcnt\x18\x03\x20\x01(\x04B\0\x12\x0f\n\x05limit\x18\x04\x20\x01(\
    \x04B\0:\0\"\x8f\x02\n\x0bMemoryStats\x12\x0f\n\x05cache\x18\x01\x20\x01\
    (\x04B\0\x12!\n\x05usage\x18\x02\x20\x01(\x0b2\x10.grpc.MemoryDataB\0\
    \x12&\n\nswap_usage\x18\x03\x20\x01(\x0b2\x10.grpc.MemoryDataB\0\x12(\n\
    \x0ckernel_usage\x18\x04\x20\x01(\x0b2\x10.grpc.MemoryDataB\0\x12\x17\n\
    \ruse_hierarchy\x18\x05\x20\x01(\x08B\0\x121\n\x05stats\x18\x06\x20\x03(\
    \x0b2\x20.grpc.MemoryStats.stats_MapEntryB\0\x1a,\n\x0estats_MapEntry\
    \x12\t\n\x03key\x18\x01(\t\x12\x0b\n\x05value\x18\x02(\x04:\x028\x01:\0\
    \"T\n\x0fBlkioStatsEntry\x12\x0f\n\x05major\x18\x01\x20\x01(\x04B\0\x12\
    \x0f\n\x05minor\x18\x02\x20\x01(\x04B\0\x12\x0c\n\x02op\x18\x03\x20\x01(\
    \tB\0\x12\x0f\n\x05value\x18\x04\x20\x01(\x04B\0:\0\"\xcc\x03\n\nBlkioSt\
    ats\x12;\n\x1aio_service_bytes_recursive\x18\x01\x20\x03(\x0b2\x15.grpc.\
    BlkioStatsEntryB\0\x126\n\x15io_serviced_recursive\x18\x02\x20\x03(\x0b2\
    \x15.grpc.BlkioStatsEntryB\0\x124\n\x13io_queued_recursive\x18\x03\x20\
    \x03(\x0b2\x15.grpc.BlkioStatsEntryB\0\x12:\n\x19io_service_time_recursi\
    ve\x18\x04\x20\x03(\x0b2\x15.grpc.BlkioStatsEntryB\0\x127\n\x16io_wait_t\
    ime_recursive\x18\x05\x20\x03(\x0b2\x15.grpc.BlkioStatsEntryB\0\x124\n\
    \x13io_merged_recursive\x18\x06\x20\x03(\x0b2\x15.grpc.BlkioStatsEntryB\
    \0\x122\n\x11io_time_recursive\x18\x07\x20\x03(\x0b2\x15.grpc.BlkioStats\
    EntryB\0\x122\n\x11sectors_recursive\x18\x08\x20\x03(\x0b2\x15.grpc.Blki\
    oStatsEntryB\0:\0\"I\n\x0cHugetlbStats\x12\x0f\n\x05usage\x18\x01\x20\
    \x01(\x04B\0\x12\x13\n\tmax_usage\x18\x02\x20\x01(\x04B\0\x12\x11\n\x07f\
    ailcnt\x18\x03\x20\x01(\x04B\0:\0\"\xbc\x02\n\x0bCgroupStats\x12#\n\tcpu\
    _stats\x18\x01\x20\x01(\x0b2\x0e.grpc.CpuStatsB\0\x12)\n\x0cmemory_stats\
    \x18\x02\x20\x01(\x0b2\x11.grpc.MemoryStatsB\0\x12%\n\npids_stats\x18\
    \x03\x20\x01(\x0b2\x0f.grpc.PidsStatsB\0\x12'\n\x0bblkio_stats\x18\x04\
    \x20\x01(\x0b2\x10.grpc.BlkioStatsB\0\x12A\n\rhugetlb_stats\x18\x05\x20\
    \x03(\x0b2(.grpc.CgroupStats.hugetlb_stats_MapEntryB\0\x1aH\n\x16hugetlb\
    _stats_MapEntry\x12\t\n\x03key\x18\x01(\t\x12\x1f\n\x05value\x18\x02(\
    \x0b2\x12.grpc.HugetlbStats:\x028\x01:\0\"\xca\x01\n\x0cNetworkStats\x12\
    \x0e\n\x04name\x18\x01\x20\x01(\tB\0\x12\x12\n\x08rx_bytes\x18\x02\x20\
    \x01(\x04B\0\x12\x14\n\nrx_packets\x18\x03\x20\x01(\x04B\0\x12\x13\n\trx\
    _errors\x18\x04\x20\x01(\x04B\0\x12\x14\n\nrx_dropped\x18\x05\x20\x01(\
    \x04B\0\x12\x12\n\x08tx_bytes\x18\x06\x20\x01(\x04B\0\x12\x14\n\ntx_pack\
    ets\x18\x07\x20\x01(\x04B\0\x12\x13\n\ttx_errors\x18\x08\x20\x01(\x04B\0\
    \x12\x14\n\ntx_dropped\x18\t\x20\x01(\x04B\0:\0\"r\n\x16StatsContainerRe\
    sponse\x12)\n\x0ccgroup_stats\x18\x01\x20\x01(\x0b2\x11.grpc.CgroupStats\
    B\0\x12+\n\rnetwork_stats\x18\x02\x20\x03(\x0b2\x12.grpc.NetworkStatsB\0\
    :\0\"Q\n\x12WriteStreamRequest\x12\x16\n\x0ccontainer_id\x18\x01\x20\x01\
    (\tB\0\x12\x11\n\x07exec_id\x18\x02\x20\x01(\tB\0\x12\x0e\n\x04data\x18\
    \x03\x20\x01(\x0cB\0:\0\"&\n\x13WriteStreamResponse\x12\r\n\x03len\x18\
    \x01\x20\x01(\rB\0:\0\"O\n\x11ReadStreamRequest\x12\x16\n\x0ccontainer_i\
    d\x18\x01\x20\x01(\tB\0\x12\x11\n\x07exec_id\x18\x02\x20\x01(\tB\0\x12\r\
    \n\x03len\x18\x03\x20\x01(\rB\0:\0\"&\n\x12ReadStreamResponse\x12\x0e\n\
    \x04data\x18\x01\x20\x01(\x0cB\0:\0\"@\n\x11CloseStdinRequest\x12\x16\n\
    \x0ccontainer_id\x18\x01\x20\x01(\tB\0\x12\x11\n\x07exec_id\x18\x02\x20\
    \x01(\tB\0:\0\"c\n\x13TtyWinResizeRequest\x12\x16\n\x0ccontainer_id\x18\
    \x01\x20\x01(\tB\0\x12\x11\n\x07exec_id\x18\x02\x20\x01(\tB\0\x12\r\n\
    \x03row\x18\x03\x20\x01(\rB\0\x12\x10\n\x06column\x18\x04\x20\x01(\rB\0:\
    \0\"\xa8\x01\n\x14CreateSandboxRequest\x12\x12\n\x08hostname\x18\x01\x20\
    \x01(\tB\0\x12\r\n\x03dns\x18\x02\x20\x03(\tB\0\x12!\n\x08storages\x18\
    \x03\x20\x03(\x0b2\r.grpc.StorageB\0\x12\x17\n\rsandbox_pidns\x18\x04\
    \x20\x01(\x08B\0\x12\x14\n\nsandbox_id\x18\x05\x20\x01(\tB\0\x12\x19\n\
    \x0fguest_hook_path\x18\x06\x20\x01(\tB\0:\0\"\x19\n\x15DestroySandboxRe\
    quest:\0\"6\n\nInterfaces\x12&\n\nInterfaces\x18\x01\x20\x03(\x0b2\x10.t\
    ypes.InterfaceB\0:\0\"*\n\x06Routes\x12\x1e\n\x06Routes\x18\x01\x20\x03(\
    \x0b2\x0c.types.RouteB\0:\0\"A\n\x16UpdateInterfaceRequest\x12%\n\tinter\
    face\x18\x01\x20\x01(\x0b2\x10.types.InterfaceB\0:\0\"7\n\x13UpdateRoute\
    sRequest\x12\x1e\n\x06routes\x18\x01\x20\x01(\x0b2\x0c.grpc.RoutesB\0:\0\
    \"\x19\n\x15ListInterfacesRequest:\0\"\x15\n\x11ListRoutesRequest:\0\"N\
    \n\x13OnlineCPUMemRequest\x12\x0e\n\x04wait\x18\x01\x20\x01(\x08B\0\x12\
    \x11\n\x07nb_cpus\x18\x02\x20\x01(\rB\0\x12\x12\n\x08cpu_only\x18\x03\
    \x20\x01(\x08B\0:\0\"*\n\x16ReseedRandomDevRequest\x12\x0e\n\x04data\x18\
    \x02\x20\x01(\x0cB\0:\0\"\x8d\x01\n\x0cAgentDetails\x12\x11\n\x07version\
    \x18\x01\x20\x01(\tB\0\x12\x15\n\x0binit_daemon\x18\x02\x20\x01(\x08B\0\
    \x12\x19\n\x0fdevice_handlers\x18\x03\x20\x03(\tB\0\x12\x1a\n\x10storage\
    _handlers\x18\x04\x20\x03(\tB\0\x12\x1a\n\x10supports_seccomp\x18\x05\
    \x20\x01(\x08B\0:\0\"N\n\x13GuestDetailsRequest\x12\x18\n\x0emem_block_s\
    ize\x18\x01\x20\x01(\x08B\0\x12\x1b\n\x11mem_hotplug_probe\x18\x02\x20\
    \x01(\x08B\0:\0\"\x8a\x01\n\x14GuestDetailsResponse\x12\x1e\n\x14mem_blo\
    ck_size_bytes\x18\x01\x20\x01(\x04B\0\x12+\n\ragent_details\x18\x02\x20\
    \x01(\x0b2\x12.grpc.AgentDetailsB\0\x12#\n\x19support_mem_hotplug_probe\
    \x18\x03\x20\x01(\x08B\0:\0\";\n\x18MemHotplugByProbeRequest\x12\x1d\n\
    \x13memHotplugProbeAddr\x18\x01\x20\x03(\x04B\0:\0\":\n\x17SetGuestDateT\
    imeRequest\x12\r\n\x03Sec\x18\x01\x20\x01(\x03B\0\x12\x0e\n\x04Usec\x18\
    \x02\x20\x01(\x03B\0:\0\"\x85\x01\n\x07Storage\x12\x10\n\x06driver\x18\
    \x01\x20\x01(\tB\0\x12\x18\n\x0edriver_options\x18\x02\x20\x03(\tB\0\x12\
    \x10\n\x06source\x18\x03\x20\x01(\tB\0\x12\x10\n\x06fstype\x18\x04\x20\
    \x01(\tB\0\x12\x11\n\x07options\x18\x05\x20\x03(\tB\0\x12\x15\n\x0bmount\
    _point\x18\x06\x20\x01(\tB\0:\0\"h\n\x06Device\x12\x0c\n\x02id\x18\x01\
    \x20\x01(\tB\0\x12\x0e\n\x04type\x18\x02\x20\x01(\tB\0\x12\x11\n\x07vm_p\
    ath\x18\x03\x20\x01(\tB\0\x12\x18\n\x0econtainer_path\x18\x04\x20\x01(\t\
    B\0\x12\x11\n\x07options\x18\x05\x20\x03(\tB\0:\0\"F\n\nStringUser\x12\r\
    \n\x03uid\x18\x01\x20\x01(\tB\0\x12\r\n\x03gid\x18\x02\x20\x01(\tB\0\x12\
    \x18\n\x0eadditionalGids\x18\x03\x20\x03(\tB\0:\0\"\xa1\x01\n\x0fCopyFil\
    eRequest\x12\x0e\n\x04path\x18\x01\x20\x01(\tB\0\x12\x13\n\tfile_size\
    \x18\x02\x20\x01(\x03B\0\x12\x13\n\tfile_mode\x18\x03\x20\x01(\rB\0\x12\
    \x12\n\x08dir_mode\x18\x04\x20\x01(\rB\0\x12\r\n\x03uid\x18\x05\x20\x01(\
    \x05B\0\x12\r\n\x03gid\x18\x06\x20\x01(\x05B\0\x12\x10\n\x06offset\x18\
    \x07\x20\x01(\x03B\0\x12\x0e\n\x04data\x18\x08\x20\x01(\x0cB\0:\0\"\x17\
    \n\x13StartTracingRequest:\0\"\x16\n\x12StopTracingRequest:\0B\0b\x06pro\
    to3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
